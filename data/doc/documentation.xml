<?xml version="1.0" encoding="UTF-8"?>
<?teipublisher odd="docbook.odd" template="documentation.html" depth="3" fill="2"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.0">
  <info>
    <title>TEI Publisher Documentation</title>
    <author>
      <personname>
        <firstname>Wolfgang</firstname>
        <surname>Meier</surname>
      </personname>
      <affiliation>
        <orgname>eXist Solutions GmbH</orgname>
      </affiliation>
    </author>
    <author>
      <personname>
        <firstname>Magdalena</firstname>
        <surname>Turska</surname>
      </personname>
      <affiliation>
        <orgname>eXist Solutions GmbH</orgname>
      </affiliation>
    </author>
    <keywordset vocab="#genre">
      <keyword>Documentation</keyword>
    </keywordset>
  </info>
  <section>
    <title>Introduction</title>
    <section>
      <title>What TEI Publisher does ...</title>
      <para>The vision behind TEI Publisher is to provide a tool which enables scholars and editors
        to publish their materials without becoming programmers, but also does not force them into a
        one-size-fits-all framework. Experienced developers will benefit as well by writing less
        code, avoiding redundancy, improve maintenance and interoperability - to just name a few.
        TEI Publisher is all about <emphasis role="bold">standards</emphasis>, <emphasis role="bold"
          >modularity</emphasis>, <emphasis role="bold">reusability</emphasis> and <emphasis
          role="bold">sustainability</emphasis>!</para>
      <para>In Publisher, it all starts with your source documents - regardless if they are in TEI
        or other form of XML: DocBook, MS Word (DOCX) or JATS. However the source material has been
        encoded, it can be easily transformed into a range of output formats for publication - from
        a modern web page that you can open on your laptop or mobile device, to an ebook, a PDF file
        or its LaTeX source.</para>
      <para>TEI Publisher derives its name from TEI and the TEI Processing Model (PM). Processing
        Model is a part of the TEI vocabulary and TEI ODD specification format, described in the
          <link xlink:show="new"
          xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/TD.html#TDPM">TEI P5
          guidelines</link> as well as further chapters here. It defines how a TEI document should
        be rendered in different output formats and lies at the heart of TEI Publisher.</para>
      <para>However, online editions require more than just a text transformation: the text needs to
        be embedded into an application context, adding navigation, pagination, search, facsimile
        display and so on. The larger part of TEI Publisher deals with those aspects, providing all
        the necessary building blocks for an online edition.</para>
      <para>Staying true to the spirit of code reuse and interoperability, TEI Publisher implements
        all functionality as small "lego" blocks to be freely arranged and recombined. The
        technology making this possible is called <emphasis>Web Components</emphasis>. It is part of
        the HTML5 specification and natively implemented by many browsers. Users don't need to dive
        into the details of this standard though: all you need to modify the example pages is a bit
        of basic HTML knowledge.</para>
      <para>Only where the <link xlink:show="new" xlink:href="../../pb-components-api/index.html"
          >available components</link> are not enough, a new use case needs to be described and
        suitable new components implemented but then they can be incorporated into existing
        component pool for everyone else to use. After all, our mantra is reuse, reuse, reuse and we
        want to turn TEI Publisher into a box of tools the entire community can benefit from. See
        our <link linkend="roadmap">roadmap</link> for the ideas we are thinking of.</para>
      <para>Despite elegant simplicity of this approach, various projects we realized in the past
        prove that TEI Publisher is:</para>
      <orderedlist>
        <listitem>
          <para>powerful enough to cover complex transformation needs</para>
        </listitem>
        <listitem>
          <para>a truly universal tool for any kind of digital edition</para>
        </listitem>
        <listitem>
          <para>capable of generating high quality, camera ready material for book publishing</para>
        </listitem>
        <listitem>
          <para>sustainable and future-proof solution</para>
        </listitem>
        <listitem>
          <para>suitable for any XML, not just TEI (this documentation is written in
            DocBook!)</para>
        </listitem>
      </orderedlist>
    </section>
    <section>
      <title>e-editiones.org</title>
      <para>Since its first incarnation in 2015, TEI Publisher gained substantial following with
        numerous academic and commercial projects around the globe using it for their editorial and
        publishing needs. Grass-roots user initiative led in 2020 to the foundation of an
        international non-profit association <link xlink:show="new"
          xlink:href="https://e-editiones.org">e-editiones.org</link> with the focus on further
        joint development of TEI Publisher, open standards and best practices for digital
        editions.</para>
    </section>
    <section xml:id="versions">
      <title>Versions</title>
      <para>TEI Publisher is actively developed since 2015. Once or twice a year a new major version
        is released, bringing important new features.</para>
      <para>Minor versions are released inbetween and these offer bug fixes, minor new features and
        improvements.</para>
      <para>Current major version of the TEI Publisher is 6.0.0</para>

      <section xml:id="v6">
        <title>What's new in TEI Publisher 6.0.0</title>
        <para>Version 6 brought a major refactoring and restructuring of TEI Publisher app libraries
          along with new specialized components and use case examples.</para>
        <orderedlist>
          <listitem>
            <para>Web components overhaul: migration to <link xlink:show="new"
                xlink:href="https://lit-element.polymer-project.org/">LitElement</link> and move to
              npm library</para>
            <para>While invisible to users, this redesign greatly improved modularity of
              Publisher-based applications. With Publisher web component releases published on npm,
              updating the user interface for all Publisher-based apps is just a question of
              changing a single variable in the configuration file.</para>
            <para>Furthermore, Publisher's library of web components - true to the basic idea of
                <link xlink:show="new"
                xlink:href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
                Components Standard</link> can be included in any HTML webpage e.g. can be embedded
              into existing CMS or any other publishing solution, even if it's not running
              eXist-db.</para>
            <para>Similarly, if you prefer to write your own application using any of the popular
              frameworks like angular, vue or react you can easily import the
                <code>pb-components</code> package from npm and use it directly in your
              project.</para>
            <para>As a final consequence, this change decouples the component library from the TEI
              Publisher app. It is now possible to host multiple applications, which depend on
              different versions of the component library, without conflict within the same eXist-db
              instance, a point of importance for institutions with numerous projects.</para>
          </listitem>
          <listitem>
            <para>Redesigned and simplified CSS styling customization</para>
            <para>Encapsulation of styles offered by web components can be a mixed blessing and
              poses some challenges when customizing the aesthetics of components to fit a project.
              While some aspects of component styling remained unaccessible for customization in
              previous versions, Publisher 6 exposes majority of styling properties via standard CSS
              files and theme variables. Stylesheets can also be specified within the ODD, as
              previously, or through <code>pb-view</code> component configuration attributes.</para>
          </listitem>
          <listitem>
            <para>Extended internationalization</para>
            <para>I18n support has been extended to cover not only the labels in HTML templates but
              also within web components. A mechanism for project specific language files extending
              the default Publisher label collection has been added.</para>
            <para>Thanks to community contributions via <link xlink:show="new"
                xlink:href="https://crwd.in/tei-publisher">Crowdin</link> a number of new languages
              has been added and existing ones updated.</para>
          </listitem>
          <listitem>
            <para>Subcorpora - new TEI Publisher data organization</para>
            <para>Publisher's pre-populated data collection is now split into
                <emphasis>Playground</emphasis> and <emphasis>TEI Publisher demo
                collection</emphasis> areas which illustrate how this mechanism could be used to
              host multiple subcorpora within single TEI Publisher application.</para>
          </listitem>
          <listitem>
            <para>New and improved web components</para>
            <para><code>pb-select-feature</code> and <code>pb-toggle-feature</code> components have
              been extended to allow for interactive changing of display parameters (like switching
              between regularized or original spelling) which can be then processed client or
              server-side.</para>
            <para>New components have been created for API documentation app and web component demo
              pages.</para>
          </listitem>
          <listitem>
            <para>User interface of the ODD editor has been improved.</para>
          </listitem>
          <listitem>
            <para>Experimental incremental scroll mode has been introduced to improve performance
              for very long documents presented in single page mode.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
  <section>
    <title>Quickstart</title>
    <section xml:id="installation">
      <title>Installation</title>
      <para>TEI Publisher requires <link xlink:show="new" xlink:href="http://exist-db.org">eXist XML
          database</link> to operate. It is distributed as an eXist application package, making it
        easy to install on any eXist database instance - either on your local machine or any remote
        server.</para>
      <para>You can install eXist and TEI Publisher manually, as described below, or alternatively
        use the provided <link linkend="docker">docker image</link>.</para>

      <section xml:id="exist-installation">
        <title>Installing into an eXist instance</title>

        <section xml:id="java">
          <title>Java</title>
          <para>Before installing eXist, make sure you have Java installed on your machine. You can
            run <command>java -version</command> on a command line to check which version of Java
            you have. Make sure you have at least Java 8 (recommended: Java 11). Please note that
            the <command>java -version</command> shows the full version string, so 1.8.0 or similar
            instead of just 8.</para>
          <para>If you do not have Java installed, you can choose between a variety of different
            Java distributions for your operating system. While these are largely equivalent, so far
            we had smoothest installation experience across operating systems with the <link
              xlink:show="new"
              xlink:href="https://www.azul.com/downloads/zulu-community/?package=jdk">Zulu Community
              OpenJDK</link> builds. In particular for Windows users, this provides the best out of
            the box experience.</para>
        </section>
        <section xml:id="download">
          <title>Download</title>

          <para>Download an eXist distribution following the link on its <link xlink:show="new"
              xlink:href="http://exist-db.org/exist/apps/homepage/index.html#downloads"
              >homepage</link>. </para>

          <note>
            <para>It is recommended that you set up an admin password when installing eXist but make
              sure to remember or store it securely!</para>
          </note>
        </section>

        <section xml:id="mac-installation">
          <title>Mac installation</title>
          <para>On a Mac download the file with the <command>.dmg</command> extension, e.g.
              "<filename>eXist-db-5.x.x.dmg</filename>".</para>


          <para>Double clicking the downloaded <command>.dmg</command> file should install eXist on
            your local system. It is only required to drag the eXist app icon over to the
            Applications folder. </para>

          <para>Once the installation has completed, you should find an app in your Applications
            folder which you can use to launch eXist.</para>
        </section>

        <section xml:id="windows-installation">
          <title>Windows installation</title>
          <para>On Windows download the file with the <command>.jar</command> extension, e.g.
              "<filename>exist-installer-5.x.x.jar</filename>".</para>

          <para>Double clicking the <command>.jar</command> should install eXist on your local
            system. It will launch an installer to guide you through basic settings. Default
            settings suggested by the installer provide a good starting point for most projects so
            there's no need to change anything.</para>

          <note>
            <para>If double-clicking the <command>.jar</command> does not have any effect, there's
              may be something wrong with your Java setup. The <filename>java</filename> binary
              needs to be in your <envar>%PATH%</envar> environment.</para>
            <para>You can also try to manually start the installer by opening a command prompt,
              changing to the directory where you downloaded the distribution and typing:</para>
            <synopsis>java -jar exist-installer-5.x.x.jar</synopsis>
          </note>

          <para>Once the installation is completed, you should find an eXist-db shortcut to launch
            eXist.</para>
        </section>

        <section xml:id="unix-installation">
          <title>Unix installation</title>
          <para>Download the file with the <command>.jar</command> extension, e.g.
              "<filename>exist-installer-5.x.x.jar</filename>".</para>

          <para>Double clicking the <command>.jar</command> should install eXist on your local
            system. It will launch an installer to guide you through basic settings. Default
            settings suggested by the installer provide a good starting point for most projects so
            there's no need to change anything.</para>

          <para>Once the installation is completed, you should find an eXist-db shortcut to launch
            eXist, otherwise navigate to the installation directory and run
              <command>bin/startup.sh</command>.</para>

          <note>
            <para>Some <emphasis>Linux users</emphasis> may prefer the plain
                <command>.tar.bz2</command> package, which can just be untarred to any location.
              This package does not include an installer and eXist has to be launched on the command
              line: navigate into the untarred directory and run</para>
            <synopsis>bin/startup.sh</synopsis>
            <para>in a shell, skipping the jar installer step above. Ignore the next section,
              navigate directly to <link xlink:show="new" xlink:href="http://localhost:8080"
                >http://localhost:8080</link> and follow the steps for installing TEI Publisher via
              the dashboard described further below.</para>
          </note>
        </section>

        <section xml:id="first-launch">
          <title>First launch</title>
          <para>Once eXist is launched for the first time you should see (with the exception of some
            Unix system configurations described above) a splash window popping up, showing that
            some default applications are being installed:</para>
          <figure>
            <title>Splash Screen on eXist Startup</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistSplash.png" width="256px"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Upon first start, an additional configuration window will pop up on Windows and Mac,
            allowing you to configure basic parameters. Default settings suggested provide a good
            starting point for most projects so usually there's no need to change anything. </para>
          <figure>
            <title>Configuration Dialog Showing on First Start</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistInitialConfig.png" width="512px"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Clicking on <guibutton>Save</guibutton> will show a popup asking to confirm the
            location of the data directory. Unless you have specific requirements just agree to the
            suggestion of the configuration dialog.</para>
          <para><emphasis>Windows users</emphasis> will be asked if they would like to install eXist
            as a service. This is highly recommended to ensure that the database is correctly closed
            whenever the operating system shuts down.</para>
          <para>If all went well, eXist should now be up and running in the background. Mac and
            Windows users should find a small eXist icon in their task bar. Right-clicking on it
            will reveal a menu:</para>
          <figure>
            <title>Taskbar Launcher Context Menu</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistTaskbarIcon.png" width="512px"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section xml:id="packageManager">
          <title>Installing TEI Publisher</title>
          <para>Clicking on <guimenuitem>Open Dashboard</guimenuitem> in the taskbar will open a
            browser and display eXist's Dashboard: the central administrative hub for the database.
            Alternatively - e.g. when you chose the manual installation on Linux - you can also open
            a browser window and navigate to: <link xlink:show="new"
              xlink:href="http://localhost:8080">http://localhost:8080</link>.</para>
          <para>Log into the dashboard using the admin account and the password you chose during the
            installation (it will be empty by default). Use the left sidebar to navigate to the
              <guimenuitem>Package Manager</guimenuitem>. You'll see two tabs: the first one lists
            the application packages currently installed, the second can be used to install
            additional packages from eXist's public application repository.</para>
          <para>Switch to the <guimenuitem>Available</guimenuitem> tab and search the list for TEI
            Publisher. Once you find it, click on the little install icon.</para>
          <para>After installing you will find the TEI Publisher icon in the tab showing installed
            apps. Click on it to open the TEI Publisher.</para>
          <figure>
            <title>Installing <emphasis>TEI Publisher</emphasis> from the Package Manager</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eXistDashboard.png" width="640px"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
      </section>
      <section xml:id="docker">
        <title>Using docker</title>
        <para>If you do not want to install eXist yourself, you can use docker to run TEI Publisher.
          Docker is a tool to simplify the installation of applications and services. It creates a
          virtual environment including everything required for the service to run. Using our <link
            xlink:show="new"
            xlink:href="https://cloud.docker.com/u/existdb/repository/registry-1.docker.io/existdb/tei-publisher"
            >docker image</link>, eXist will already be set up to include TEI Publisher as well as
          the Shakespeare and Van Gogh demo apps.</para>
        <procedure>
          <step>
            <para>Install <link xlink:show="new" xlink:href="https://www.docker.com/">docker</link>
              on your machine. Windows and Mac users may download the <link xlink:show="new"
                xlink:href="https://www.docker.com/products/docker-desktop">docker desktop</link>
              app.</para>
          </step>
          <step>
            <para>To download the image run the following in a console</para>
            <synopsis>docker pull existdb/teipublisher:latest</synopsis>
          </step>
          <step>
            <para>once the download is complete, you can run the image with the following
              command:</para>
            <synopsis>docker run -p 8081:8080 -p 8444:8443 --name teipublisher existdb/teipublisher:latest</synopsis>
            <para>Startup should be fast because the database is already pre-populated. However,
              changes you make may not persist if the docker container is deleted or updated to a
              newer release. If you want to be sure that your changes are safe, you should specify a
              local volume for storing the database by adding:</para>
            <synopsis>-v exist-data:/exist-data</synopsis>
            <para>See below for an explanation of the parameters:</para>
            <variablelist>
              <varlistentry>
                <term>-p</term>
                <listitem>
                  <para>Maps a port on your local machine (8081 and 8444) to the port used by eXist
                    within the container. eXist will always run on 8080 for HTTP and 8443 for HTTPS.
                    If those ports are already occupied by different services on your machine,
                    choose a different port for the first number.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>-v</term>
                <listitem>
                  <para>Creates a named ("exist-data") volume for storing the database, using the
                    directory specified after the colon. If you skip this, any changes to the
                    database will be lost if you remove the docker container, update it or create a
                    new one. With <option>-v</option> the data will be stored outside the
                    container.</para>
                  <para>If you just intend to play around a bit, you can skip the parameter.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>--name</term>
                <listitem>
                  <para>Assigns a name to the container, so you can reference it in other docker
                    commands, like <code>docker stop</code>. We'll use the name in all commands
                    below.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>Once the container has started, you can access the eXist dashboard in your browser
              by navigating to</para>
            <synopsis>http://localhost:8081</synopsis>
            <para>From the dashboard you can click on the TEI Publisher, Shakespeare or Van Gogh
              icons to open the corresponding applications.</para>
          </step>
          <step>
            <para>To stop the container run</para>
            <synopsis>docker stop teipublisher</synopsis>
          </step>
          <step>
            <para>To start the container again:</para>
            <synopsis>docker start teipublisher</synopsis>
            <para>Note that when you restart a container, it will run in detached mode, so you won't
              see any console output. You can view the output with following command though:</para>
            <synopsis>docker logs teipublisher</synopsis>
          </step>
        </procedure>
        <section>
          <title>Other useful commands</title>
          <variablelist>
            <varlistentry>
              <term>docker container ps -a</term>
              <listitem>
                <para>Lists all running and stopped containers</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker volume ls</term>
              <listitem>
                <para>Displays existing volumes (where your database is stored)</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker cp teipublisher:/exist-data .</term>
              <listitem>
                <para>Copy the contents of the database data volume to the current directory on
                  local disk, so you can back it up. Note that this will copy the raw database files
                  as created by eXist (not your XML, which is binary encoded inside those files).
                  Also make sure you run the command after stopping the active container.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>docker volume rm exist-data</term>
              <listitem>
                <para>Remove the contents of the database data volume (in case you would like to
                  start from scratch, deleting all changes you made).</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Have a look at the docker documentation and <link xlink:show="new"
              xlink:href="https://www.docker.com/sites/default/files/Docker_CheatSheet_08.09.2016_0.pdf"
              >cheatsheet</link> for more commands.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Browsing Documents</title>
      <section>
        <title>The Start Page</title>
        <para>The start page of TEI Publisher serves as an entry point to explore and
          experiment.</para>
        <para>On a newly installed TEI Publisher the main application panel offers the choice
          between browsing local collections directly or using DTS API to access remote resources.
          Narrower panel to the right displays the list of ODD files provided with the TEI
          Publisher.</para>

        <figure>
          <title>Start Page Collections</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="start-page-collections.png" width="512px"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The usual starting point is the <emphasis role="bold">TEI Publisher Demo
            Collection</emphasis> with which users can explore a range of <link
            linkend="selected-use-cases">selected use cases</link>, demonstrating various genres,
          encoding styles and presentation layouts. Various customization aspects are handled using
          different ODDs and view templates. We suggest to have a look at each of them to see what
          TEI Publisher can achieve out of the box.</para>

        <note>
          <title>Note</title>
          <para>Documents in this collection are preinstalled with the TEI Publisher and users are
            not allowed to write to it by default.</para>
        </note>

        <para>The <emphasis role="bold">Playground</emphasis> collection is the place to upload
          encoded documents and ODD files to experiment with various processing models and view
          templates.</para>

        <para>Unlike the Demo collection, the Playground features an upload box to import new
          documents. You can upload your own XML and ODD (e.g. TEI, DocBook or DOCX) documents by
          either clicking on the <code>upload</code> button or dragging and dropping files onto the
          upload panel. Read more on this subject in the <link linkend="upload">Upload</link>
          section</para>
        <note>
          <title>Note</title>
          <para>You need to be <emphasis role="bold">logged in</emphasis> for most advanced actions
            like creating or editing ODDs. The login button to the right of the menu bar allows you
            to log in. By default, there's a user named <parameter>tei</parameter> with password
              <parameter>simple</parameter>.</para>
        </note>
      </section>
      <section>
        <title>TEI Publisher Demo collection</title>
        <para>Experiment with browsing, faceting, filtering and sorting features of TEI Publisher.
          This page consists of several main areas:<orderedlist>
            <listitem>
              <para>the facets panel</para>
            </listitem>
            <listitem>
              <para>the list of documents currently installed with sorting and filtering
                controls</para>
            </listitem>
            <listitem>
              <para>a panel showing the ODD files known to the application</para>
            </listitem>
            <listitem>
              <para>an upload box to upload new documents</para>
            </listitem>
          </orderedlist>
        </para>

        <para>Have a look at documents showcased here to get a sense of possibilities that TEI
          Publisher offers. Click on document title to proceed to the Document View</para>
        <figure>
          <title>Browsing Demo collection</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="demo-collection-overview.png" width="512px"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section xml:id="selected-use-cases">
      <title>Selected Use Cases</title>
      <para>The document view can vary, sometimes substantially, depending on the sample document
        you are looking at. This is a natural consequence of TEI's versatility and broad scope of
        its application. What follows, requirements for the document view - both its layout and
        composition as well as processing rules governing the transformation of the text of the
        document itself - will differ to a great extent. Sample documents which are included in TEI
        Publisher's installation package do not exhaust its applications but rather aim to present
        some chosen use cases:</para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Critik der reinen Vernunft</emphasis> from the <emphasis>Deutsches
              Textarchiv</emphasis> corpus presents a philosophical tractate, originally published
            in print, thus following 'traditional' book structure with front pages, foreword and
            chapters. It can nevertheless demonstrate very well Publisher's capacities in
            typesetting, switching between physical and logical structure of the document (just
            toggle <guibutton>Page View</guibutton> in the <guibutton>Settings</guibutton> panel) as
            well as generation of multiple output formats from single set of processing models in
            the ODD (try choosing <parameter>PDF</parameter> or <parameter>ePub</parameter> options
            in the <guibutton>Download</guibutton>). <emphasis>Purchas his pilgrimages</emphasis>,
            from the <emphasis>EEBO-TCP</emphasis> project, while roughly similar in structure is
            much earlier work (1613) and demonstrates extensive use of marginal notes.</para>
        </listitem>
        <listitem>
          <para>Shakespeare's <emphasis>Romeo and Juliet</emphasis>, from <emphasis>Bodleian First
              Folio</emphasis> project uses dedicated TEI elements to encode structure of the play
            but it also showcases the parallel transcription and facsimile alignment for its
            presentation which is obviously of general application and could be used for any genre,
            not limited to dramatic texts.</para>
        </listitem>
        <listitem>
          <para>Correspondence corpora are common, yet very interesting, subjects for digital
            editions. Despite basic similarities in structure, depending on the period, scope and
            particular research perspective, intended presentation may vary enormously. We are
            presenting samples of:</para>
          <itemizedlist>
            <listitem>
              <para>15th century manuscript letter to <emphasis role="bold">Mikołaj Orlik</emphasis>
                demonstrating alignment between Latin original and parallel Polish
                translation,</para>
            </listitem>
            <listitem>
              <para>16th century manuscript letter of <emphasis role="bold">Hernán Cortés</emphasis>
                showcasing parallel transcription/translation and facsimile view and transcription
                enhanced with commentaries and explicitly encoded transcriptional features,</para>
            </listitem>
            <listitem>
              <para>16th century manuscript letter of <emphasis role="bold">Mauritius
                  Ferber</emphasis> with a collapsible metadata panel in addition to the parallel
                transcription and facsimile view,</para>
            </listitem>
            <listitem>
              <para>early 19th century manuscript collocative dictionary of Polish <emphasis
                  role="bold">Bogactwa mowy polskiej</emphasis> featuring interactive highlights for
                regions of interest of the facsimile when hovering over dictionary headwords,</para>
            </listitem>
            <listitem>
              <para>A letter from <emphasis role="bold">Van Gogh</emphasis> to Paul Gauguin written
                in 1888. This intentionally reproduces the flexible column layout pioneered by the
                  <link xlink:show="new" xlink:href="http://vangoghletters.org">Vincent Van Gogh
                  Letters</link> online edition, which is a model example for correspondence.</para>
            </listitem>
            <listitem>
              <para>20th century manuscript letter from <emphasis>Robert Graves</emphasis> where
                emphasis has been put on visualizing rich encoding of semantic information in the
                letter, in particular geographic and prosopographical data.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <note>
        <title>Note</title>
        <para>List of samples is expected to grow and we'd like to encourage contributions
          illustrating other genres and perspectives.</para>
        <para>We'd like to stress that preparing showcases above has been only possible thanks to
          numerous projects releasing their sources openly, in particular the <link xlink:show="new"
            xlink:href="http://firstfolio.bodleian.ox.ac.uk">Bodleian First Folio</link>, <link
            xlink:show="new" xlink:href="http://www.deutschestextarchiv.de">Deutsches
            Textarchiv</link>, <link xlink:show="new" xlink:href="http://vangoghletters.org">Vincent
            Van Gogh Museum</link> and <link xlink:show="new"
            xlink:href="https://www.textcreationpartnership.org/tcp-eebo">EEBO-TCP</link>. We'd also
          like to thank William Graves and Anna Skolimowska for sharing their correspondence
          material.</para>
      </note>
    </section>

    <section xml:id="document-view">
      <title>Document View</title>
      <para>The document view can vary, depending on the sample document you are looking at.
        Nevertheless some default functionality will be shared:</para>
      <itemizedlist>
        <listitem>
          <para>the rightmost button in the toolbar opens the <guibutton>Settings</guibutton> panel.
            Here you can change the ODD being used for display as well as the view template (more
            about this later). By default, all sample documents apply the specific ODD which fits
            them best, but you can play around and select another ODD to see what happens.</para>
          <figure>
            <title>The Settings Panel</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="odd-page-template-settings.png" width="512px"/>
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
        <listitem>
          <para>the leftmost toolbar button will open a <emphasis>table of contents</emphasis> (if
            the viewed document has a division structure)</para>
        </listitem>
        <listitem>
          <para>the <guibutton>Download</guibutton> menu allows you to download the currently viewed
            document in a variety of output formats. Not all output formats work equally well for
            all examples as we have not customized every example for every media.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Experimenting with ODDs and page templates</title>
      <para>All TEI Publisher's sample documents are TEI XML files which are transformed into a HTML
        webpage for display in the browser. Two major factors determine how the final page is going
        to look like: an <emphasis role="bold">ODD</emphasis> and a <emphasis role="bold">page
          template</emphasis>. </para>

      <para>We have already mentioned in the very first section that the TEI Processing Model lies
        at the heart of the Publisher - the ODD file associated with a document defines the rules of
        transformation of the XML source file into HTML. Detailed discussion of the Processing Model
        can be found in <link linkend="pm-syntax">following chapters</link>, for now it is
        sufficient to say this is where decisions if a TEI element should be rendered inline, with a
        tooltip, or as a marginal note, are made. Simplifying things a bit the
          <emphasis>text</emphasis> of the document that you see rendered in your browser is an
        effect of applying the rules from ODD file to the source document. </para>
      <para>Nevertheless, as we demonstrated in the section on selected sample documents, in the
        application context we certainly want more than just text, however nicely typeset. From
        basic navigation controls, table of content, to facsimile display, critical apparatus,
        glossaries and maps - all of this and much more could be included in the final webpage.
        Following <emphasis>divide and conquer</emphasis> approach the TEI Publisher defines such
        specialized page elements as small, reusable blocks, using the Web Components technology.
        Components can be used like common HTML elements, thus a page template is just an HTML
        fragment which organizes the building blocks needed for a specific page.</para>
      <para>Looking more closely again at the TEI Publisher's <guibutton>Start</guibutton> page, we
        can now give more detail what is happening when any of the sample documents is loaded. On
        the right hand side there is a panel listing all ODD files available. Each of the sample
        documents includes a processing instruction which specifies default ODD and page template
        for this document. You can check what they are in <guibutton>Settings</guibutton> panel. For
        the Graves letter it would be <parameter>Graves' Letters</parameter> ODD and
          <parameter>Letter with map/facets</parameter> template.</para>
      <figure>
        <title>The Settings Panel for the Graves Letter</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="odd-page-template-settings.png" width="512px"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>It is easy to experiment with different page templates and ODDs just changing these
        options in the <guibutton>Settings</guibutton> panel. An important caveat though is that not
        every page template makes sense for every document - after all parallel alignment can only
        be successful if there is something to align, map needs coordinates to display, page view
        needs information about page breaks and so on.</para>
    </section>
    <section xml:id="upload">
      <title>Uploading your own documents</title>
      <para>If you read this, in all likelihood you already have some documents of your own you
        might want published, whether they are in TEI, DocBook, MS Word DOCX or other XML format.
        First step is to upload them into the database. You need to be <emphasis role="bold">logged
          in</emphasis> and in the Playground area to do it (check the short info on the
          <guibutton>Start</guibutton> page for user name and password). Then uploading is just a
        question of dragging your documents onto the <guibutton>Upload</guibutton> area. They will
        become available in the document list immediately after upload is completed.</para>
      <figure>
        <title>The Upload Panel</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="upload.png" width="512px"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Congratulations, now you can view your documents! Try to experiment and find the ODD and
        page template that best fits your needs and use it as a starting point for your own
        customization, if necessary. Once you are ready with these you can <link
          linkend="create-app">generate your own application</link> for your documents only, which
        packs away all the sandbox features of TEI Publisher and leaves just what is needed for
        publishing.</para>
      <para>If you attempt to upload a Microsoft Word document, the upload will automatically
        trigger upconversion of Word to TEI, using a custom ODD for the tranformation. Please note
        that the focus of this conversion is to preserve textual content, structure and basic
        semantics of the text, not provide authoritative mapping of complete set of MS Word features
        to TEI. Refer to <link linkend="docx">DOCX handling</link> section for more
        information.</para>
      <note>
        <title>Note</title>
        <para>Please bear in mind that while TEI Publisher aims to be a universal tool, the specific
          components may make certain assumptions about data they are getting and if your documents
          do not follow the same conventions it may be required to adjust parameters passed to the
          components from the page template or the component logic.</para>
        <para> By means of example - table of content component assumes that the document structure
          is represented by means of nested <parameter>div</parameter> elements and section titles
          are given in <parameter>head</parameter> element. If your project rather chooses numbered
          divisions (<parameter>div1</parameter>, <parameter>div2</parameter>) etc it may be
          advisable to adjust this to avoid customizing all navigation, table of contents and so on,
          but it is one of very rare cases where TEI Publisher exposes any predilection for a
          particular flavour of TEI.</para>
        <para>Similarly, template for aligned transcription and translation is parametrized to
          accept an XPath expression pointing to the location of the transcription and aligned
          translation. Likely for your documents this expression would have to be adjusted (unless
          of course you also have Latin texts with Polish translation structured in a similar way).
          Furthermore, to correctly display corresponding translation fragment a custom mapping
          function may need to be passed to the translation view (cf. <link
            xlink:href="templates/pages/vangogh.html" role="source"><filename>Van
            Gogh</filename></link> or <link xlink:href="templates/pages/cortez.html" role="source"
              ><filename>Cortés</filename></link> letter templates for examples)</para>
      </note>
    </section>
  </section>
  <section xml:id="data-organization">
    <title>Data</title>
    <!-- 
    ## Data

- Organisation
    - embedded data collection vs separate apps
    - Sub collections and virtual corpora
- Conventions (divs, pi) -->
  </section>
  <section xml:id="supported-input-formats">
    <title>Supported XML vocabularies</title>
    <para>TEI Publisher started as a publishing toolbox for TEI but the principles of TEI Processing
      Model were never limited to a single vocabulary. Publisher very quickly extended support to
      other XML formats. Currently TEI, DocBook, JATS and MS Word DOCX are supported out of the box
      (DOCX via automated conversion to TEI on upload).</para>
    <para>Few specificities of <emphasis>TEI</emphasis> and <emphasis>DocBook</emphasis> are listed
      below, while <emphasis>DOCX</emphasis> is discussed at length in the following section.</para>
    <para/>
    <section>
      <title>TEI</title>
      <para>In principle, any TEI document will be supported by TEI Publisher and can be displayed
        with the default page template and odd.</para>
      <para>Nevertheless, certain assumptions are made about encoding of the basic structure of the
        TEI documents for the purpose of navigation:</para>
      <itemizedlist>
        <listitem>
          <para>page beginnings are encoded with <tag>pb</tag></para>
        </listitem>
        <listitem>
          <para>column beginnings are encoded with <tag>cb</tag></para>
        </listitem>
        <listitem>
          <para>structural divisions in the document are encoded with <tag>div</tag> element</para>
        </listitem>
      </itemizedlist>
      <para>We acknowledge that TEI offers other ways to encode these features, e.g. generic
          <tag>milestone</tag> element or specialized numbered division elements like
          <tag>div1</tag>, <tag>div2</tag>, etc. TEI documents using alternative encodings will be
        still displayed as specified in the ODD, it is only for the sake of navigation or
        division-based full text search that we had to assume certain conventions to be able to
        decide what to show as the next page, column or division.</para>
      <para>We believe our choice represents most common way of using TEI but, for those who
        followed the path less travelled, the chapter on customization below briefly discusses how
        to change relevant functionality.</para>
    </section>

    <section>
      <title>DocBook</title>
      <para>DocBook support is demonstrated by this very document you are now reading,
          <filename>documentation.xml</filename>. It is written in DocBook and presented via
        dedicated <filename>docbook.odd</filename> and <filename>documentation.html</filename> page
        template.</para>
      <para>You will notice a custom processing instruction in the source code of this document
        which specifies which ODD and template to use. Experiment changing the template and ODD via
          <guibutton>Settings</guibutton> drawer to see how much impact it has on display.</para>
      <programlisting language="xml" xml:space="preserve">
          &lt;?teipublisher odd="docbook.odd" template="documentation.html" depth="3"?>
        </programlisting>
    </section>


    <section xml:id="docx">
      <title>MS Word DOCX format conversion</title>
      <para>Starting with the version 5.0.0 of the TEI Publisher a new docx handling module is
        available to allow for ingesting documents in <emphasis>docx</emphasis> format. Goal of this
        module is to provide a way to import Word documents, preserving their textual content,
        structure and basic semantics of the text, not to provide an authoritative mapping of
        complete set of MS Word features to TEI.</para>
      <para>Docx format is relatively flat, thus reconstructing logical document structure like
        divisions, lists and similar can be only based on certain heuristics. Likewise it is
        impossible to deduce semantics attributed to certain formatting decisions. For that reason
        TEI Publisher by intention ignores many style properties — trying to preserve as much as
        possible would likely just add unnecessary "noise" and result in low-quality TEI. </para>


      <section>
        <title>A word about Word</title>

        <para> A Word document is essentially a zip archive of several different XML files. These
          files store various parts - the text content, styles, embedded media files etc.
          Information most relevant for the import process have been extracted into a map, which is
          passed as a parameter to the ODD, so it is available for every element. Thus information
          about numbering styles can be accessed via <code>$parameters?nstyle(.)</code> function and
          testing if a list is bulleted could be done checking the value of
            <code>$parameters?nstyle(.)/numFmt/@w:val</code>. Full list of available functions and
          some hints how to customize default conversion ODD are provided at the <link
            linkend="docx-functions">end of this chapter</link>. </para>
        <figure>
          <title>MS Word archive structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="wordStructure.png" width="212px"/>
            </imageobject>
          </mediaobject>
        </figure>

        <variablelist>
          <varlistentry>
            <term>Named tei:* styles</term>
            <listitem>
              <para> Named styles can be strong indicators for the semantics of the text fragment.
                Styles whose name starts with <code>tei:</code> are thus recognized as TEI elements
                with the same name. If a character sequence uses a style called
                  <code>tei:persName</code>, it will be wrapped into a TEI <tag>persName</tag>
                element in the output, e.g. <code>&lt;persName&gt;Johann Wolfgang
                  Goethe&lt;/persName&gt;</code>. A place name should be marked with a style
                  <code>tei:placeName</code> and reconstructed text could be encoded by applying a
                style <code>tei:supplied</code>. </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Headings and divisions</term>
            <listitem>
              <para> Since Word does not have a concept for text division, instead storing just flat
                lists of paragraphs, so the only way to reconstruct the logical structure is to use
                Word headings and outline level associated with these to determine division
                boundaries. </para>
              <para>In the first pass, all paragraph styles starting with <code>heading</code>,
                  <code>title</code> or <code>subtitle</code> generate a <tag>tei:head</tag>
                element. The outline level assigned to the heading is recorded as well.</para>
              <para>Subsequently, in a second pass through the generated output, divisions are
                generated based on the outline level: a <tag>div</tag> spans all text from the
                heading to the next heading on the same outline level and the process is repeated
                for all headings within the division on a lower outline level.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Lists</term>
            <listitem>
              <para>Lists structure needs to be reconstructed, very much like divisions, taking into
                consideration the list level associated with every item which can be accessed via a
                call to <code>$parameters?pstyle(.)//outlineLvl/@w:val</code>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Foot- and endnotes</term>
            <listitem>
              <para> Footnotes are translated into TEI note elements. Endnotes are also supported
                and transformed into <code>&lt;note type="endnote"&gt;</code>. </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Tables</term>
            <listitem>
              <para> Processing of simple tables works very well as well as cells spanning multiple
                colums. Row spans are not implemented yet. </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Images</term>
            <listitem>
              <para> Embedded images are stored into a subcollection starting with the name of the
                docx file being processed and suffixed with <code>.media</code>, eg.
                  <code>&lt;graphic url="test.docx.media/image1.png"/&gt;</code>
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section xml:id="docx-functions">
        <title>ODD for docx</title>
        <para>The ODD used for docx processing can be found in <link xlink:href="odd/docx.odd"
            role="source">docx.odd</link>. Users are free to extend the default ODD with additional
          heuristics. For example, a paragraph being entirely bold could also be treated as a
          heading, or a left text indent may indicate a quote.</para>
        <para>For testing purposes there is a Word document provided in
            <filename>data/doc/test.docx</filename> which includes samples of most important
          features like headings, lists, tables, notes and embedded images. Try uploading it via
          upload panel as described in the <link linkend="upload">upload section</link> and check
          the conversion results. Behaviour of the conversion mostly follows the approach used in
          TEI Stylesheets docx-to-tei transformation module and has been tested on test files
          included there.</para>

        <section>
          <title>Parameter functions</title>
          <para>Functions below can be used to retrieve styles or other information related to a
            current node. For more usage examples see <link xlink:href="odd/docx.odd" role="source"
              >docx.odd</link></para>

          <variablelist>
            <varlistentry>
              <term>cstyle</term>
              <listitem>
                <para>phrase level (characters, words or phrases) styles associated with the current
                  node</para>
                <para>Returns: <code>w:style</code></para>
                <para>Usage example: <code>$parameters?cstyle(.)/name[starts-with(@w:val,
                    'tei:')]</code></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>endnote</term>
              <listitem>
                <para>content of the endnote</para>
                <para>Returns: <code>w:endnote/w:p</code></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>footnote</term>
              <listitem>
                <para>content of the footnote</para>
                <para>Returns: <code>w:footnote/w:p</code></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>link</term>
              <listitem>
                <para>external link</para>
                <para>Returns: <code>rel:Relationship</code></para>
                <para>Usage example: <code>$parameters?link(.)/@Target</code></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>nstyle</term>
              <listitem>
                <para>list style information associated with the current node</para>
                <para>Returns: <code>w:lvl</code></para>
                <para>Usage example: <code>$parameters?nstyle(.)/numFmt</code></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>pstyle</term>
              <listitem>
                <para>paragraph level styles associated with the current node</para>
                <para>Returns: <code>w:style</code></para>
                <para>Usage example: <code>$parameters?pstyle(.)/name[matches(@w:val, 'quote';,
                    'i')]</code></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>
  </section>
  <section xml:id="odd-customization">
    <title>Processing Model transformations</title>
    <para>While TEI Publisher already provides various ODDs and page templates targeting specific
      domains, it is likely that your project may require certain adjustments to fully meet your
      needs. It has been one of primary concerns in Publisher's design that customization is not
      only possible on various levels but also encouraged and we aim it to be as simple as
      possible.</para>
    <para>Very broadly we can group customization needs into two sets: changing the rules for
      document transformation (how the source document is translated into the output format) or
      changing the organization and styling of the rendered web page. In this chapter we'll
      concentrate on the former, document transformation, which primarily requires modification of
      the ODD with the <link linkend="pm-syntax">TEI Processing Model</link>. The latter would
      require <link linkend="customizing-page-template">adjustments of the page template</link>. In
      both cases, it may be best to choose as your starting point an already existing ODD or page
      template and adjust it.</para>
    <section>
      <title>ODD Customization</title>
      <section>
        <title>Creating Your First ODD</title>
        <para>The general workflow for creating a customization is as follows:<orderedlist>
            <listitem>
              <para>upload a TEI sample document you want to format</para>
            </listitem>
            <listitem>
              <para>create a new ODD</para>
            </listitem>
            <listitem>
              <para>modify the ODD to match your requirements</para>
            </listitem>
          </orderedlist>
        </para>
        <para>For the purpose of this quickstart, we will reuse one of the pre-installed sample
          documents, but create a new ODD for it (while we will start from scratch with an empty
          ODD, it is also possible to generate one based on one or more <link
            linkend="odd-by-example">sample TEI documents</link>):</para>
        <procedure>
          <step>
            <para>Log in and fill out the form at the bottom of the panel listing ODD files. Choose
              a name for the ODD, e.g. <option>myletter</option> (without a suffix) and a title,
              which will appear in the list after creation. Click on <guibutton>Create</guibutton>
              (not <guibutton>Create from examples</guibutton>).</para>
            <para>The newly created ODD should appear in the side panel.</para>
          </step>
          <step>
            <para>In the document list, click on <emphasis>Letter #6 from Robert Graves to William
                Graves</emphasis> to open it in the document viewer.</para>
          </step>
          <step>
            <para>Open the <guibutton>Settings</guibutton> panel (rightmost toolbar button, see
              above) and choose your ODD from the dropdown showing available ODDs. You may also
              change the used HTML template to <option>Default single text layout</option>, though
              this is not absolutely necessary.</para>
          </step>
          <step>
            <para>The view should change and display the letter's content with only basic formatting
              applied. Since our ODD has just been created and is empty, we see the content with
              standard formatting applied. Our ODD by default inherits from
                <filename>teipublisher.odd</filename>, which likewise extends
                <filename>tei_simplePrint.odd</filename>. The latter is maintained by the TEI
              community and contains processing model declarations for the most important TEI
              elements. Thanks to this inheritance mechanism, many documents display nicely without
              requiring a lot of additional customization.</para>
          </step>
          <step>
            <para>From the menu, select <guimenu>Admin</guimenu> / <guimenuitem>Edit
                ODD</guimenuitem> to open the visual ODD editor.</para>
          </step>
        </procedure>
      </section>
      <section>
        <title>Modify the ODD</title>
        <para>Changing processing models in the ODD is a powerful mechanism through which you can
          control all aspects of the transformation of your documents from source XML format to all
          output formats: HTML, ePUB, PDF etc. As already mentioned it is considered best practice
          to chain ODD customizations together and rather change or add project specific rules to
          more generic ODD rather than copy them in extenso. ODD chaining allows for the future
          upgrades as your base ODDs may be updated by standardization bodies which maintain them.
          Commonly project ODDs would extend <filename>teipublisher.odd</filename>, a generic TEI
          Publisher set of processing rules. </para>
        <para>Beginning with version 3.0 of TEI Publisher, you have the choice between writing the
          ODD by hand or using a visual editor. Both approaches can be combined and mixed. The
          visual editor saves the ODD in a non-destructive way, preserving any information not
          related to the processing model. It is thus safe to switch between hand-editing the ODD
          and using the visual editor. Just make sure you reload the visual editor view after
          modifying the source XML and vice versa. That said, visual editor is specifically tailored
          to editing processing models so it will be likely the fastest and safest way to edit your
          ODD.</para>
        <para>To be able to customize the display of your document it is crucial to understand its
          XML structure well. Each of processing models needs to be aimed at a particular XML
          element and sometimes is only meant for a specific XML context - let's say we might want
          to distinguish between headings of first and second level of nested divisions as they
          often represent titles of different text units: acts and scenes or books and
          chapters.</para>
        <para>We'll start with the Graves' letter you have already viewed applying your custom ODD
          in previous section. The display is quite simple and easy to read but we might want to
          adjust it to follow common visual conventions for a letter, starting with displaying the
          dateline on the right hand side and completely removing the page label which currently
          sits there.</para>
        <para> To create a processing model addressing this need we have to know 3 things: </para>
        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">when</emphasis> should it be applied, </para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">what</emphasis> is supposed to happen</para>
          </listitem>
          <listitem>
            <para>and <emphasis role="bold">how</emphasis> should the text be formatted? </para>
          </listitem>
        </itemizedlist>
        <para> To be able to answer the first question, you should familiarize yourself with the XML
          structure of the letter to find out how datelines are represented in TEI. In the tab
          displaying the letter, select <guimenuitem>Download</guimenuitem> / <guimenuitem>XML
          </guimenuitem>to open <link xlink:href="data/test/graves6.xml" role="source">
            <filename>graves6.xml</filename>
          </link> in eXide. Quick investigation of the TEI encoding will reveal that dateline
          resides in its eponymic tag <tag>dateline</tag> wchich is nested in the <tag>opener</tag>
          part of the document, while page labels are encoded with <tag>pb</tag>.</para>
        <para>We'll use the visual editor, but show the corresponding ODD XML below each screenshot.
          At the end of this chapter we'll describe how to edit the ODD XML code <link
            linkend="oddxml">by hand</link>.</para>
      </section>

      <section xml:id="visualodd">
        <title>First Steps</title>
        <para>The visual ODD editor opens if you select <guimenuitem>Admin</guimenuitem> /
            <guimenuitem>Edit ODD</guimenuitem> from the menu while viewing a document.
          Alternatively you can click on the name of an ODD in the list of ODDs on the TEI Publisher
          entry page. A new tab opens, showing an action panel to the left, and the title of your
          ODD to the right.</para>
        <note>
          <title>Note</title>
          <para><emphasis>Most recent versions of the ODD editor will look slightly different,
              nevertheless they are functionally equivalent to the screenshots below, created in an
              earlier version.</emphasis></para>
        </note>
        <para>We need to overwrite the processing model rules for <tag>dateline</tag>. Enter
            <parameter>dateline</parameter> into the input box next to the
            <guibutton>New</guibutton> button in the left panel and click the button. This will
          insert a processing model rule for <tag>dateline</tag> into the right panel. Because
            <tag>dateline</tag> already exist in the base ODD,
            <filename>tei_simplePrint.odd</filename>, you'll see a single model which was copied
          from the base ODD.</para>
        <figure>
          <title>Screen after adding <tag>dateline</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen1.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The corresponding ODD XML looks like this:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="dateline"&gt;
    &lt;model behaviour="block"/&gt;
&lt;/elementSpec&gt;</programlisting>
        <para>Let's cover some key concepts of the TEI processing model first:
            <tag>elementSpec</tag> primarily documents the structure, content, and purpose of an
          element. It is a core element in any ODD but the schema-related functions are not relevant
          for the discussion here. What is important for us is this is where processing models are
          defined. The <parameter>@ident</parameter> attribute of the <tag>elementSpec</tag>
          identifies the name of the element to which the spec (and therefore processing model)
          applies.</para>
        <para>An <tag>elementSpec</tag> may contain one or more <tag>model</tag> elements to specify
          the intended processing of this element. Every model maps the element to a
            <option>behaviour</option>. A behaviour denotes an abstract transformation function to
          be applied. The TEI guidelines currently list two dozen behaviours, e.g. paragraph,
          heading, note, inline, block. The last two are the most frequently used. How exactly a
          behaviour translates into the target output media may differ depending on media features
          and design decisions. TEI Publisher tries to implement them as generic as possible.</para>
        <para>To change the model expand it by clicking on the arrow to the left of the grey box. A
          form appears, allowing you to change the model configuration. In our example we are happy
          with <emphasis>what</emphasis> is happening with the dateline, so we don't need to change
          the behaviour but we do want to fix <emphasis>how</emphasis> it is styled by justifying it
          to the right. Rendition can be defined in an <tag>outputRendition</tag>, so click on the
            <guibutton>+</guibutton> button next to <guibutton>Renditions</guibutton>. In the form
          input being inserted below, enter your styling requirements in css.</para>
        <para>The processing model uses <tag>outputRendition</tag> and CSS to define visual aspects.
          For output formats other than XML, the CSS is translated into the corresponding target
          language. It is thus best to limit the CSS to the most common typographical features, like
          bold, italic, color, underline etc. The general styling of the text should be done outside
          the ODD to maintain a clear separation of concerns.</para>
        <figure>
          <title>Add a rendition for <tag>dateline</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen2.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Again here's the corresponding XML:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="dateline"&gt;
  &lt;model behaviour="block"&gt;
      &lt;outputRendition&gt;text-align: right;&lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <para>To test your change, click on <guibutton>Save</guibutton> in the left panel and wait a
          second until a popup appears. Switch back to the tab with Graves' letter from which you
          opened the editor and refresh the browser window to see your changes applied. In case you
          do not see any change, make sure</para>
        <orderedlist>
          <listitem>
            <para>you selected the correct ODD for viewing (check the
                <guibutton>Settings</guibutton> drawer)</para>
          </listitem>
          <listitem>
            <para>if you made changes to outputRenditions only, you may need to clear your browser's
              cached version. For most browsers, holding the shift key while clicking on the reload
              button does the job.</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>Other behaviours</title>
        <para>We would also like to hide the page breaks as we do not have facsimiles available. Add
          a new element spec for <tag>pb</tag>. Again the newly added spec already includes a model
          with behaviour <option>break</option>. Just change this behaviour to <option>omit</option>
          or delete the existing model and insert a fresh one with behaviour
          <option>omit</option>.</para>
        <figure>
          <title>Omit <tag>pb</tag>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen3.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="pb"&gt;
  &lt;model behaviour="omit"/&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>
      <section>
        <title>Predicates and multiple models</title>
        <para>Next up, we may want to highlight the various places and people occurring within the
          text. They are all marked up with the <tag>name</tag> tag, using different
            <option>@type</option> attributes. Create a new element spec for <tag>name</tag> and
          supply some color to the names.</para>
        <figure>
          <title>Color the <tag>name</tag> tags </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen4.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>And the XML for the entire <tag>elementSpec</tag>:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="name" mode="change"&gt;
    &lt;model behaviour="inline"&gt;
        &lt;outputRendition&gt;
        color: #FF9900;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <para>This rule affects places and people alike since both these categories are marked up
          with <tag>name</tag> tag. If we'd like to treat people and places differently we'd need
          separate models for them and a mechanism to distinguish between the two. The processing
          model uses <option>predicate</option> to make such distinctions: a model rule will only be
          used if the XPath expression in its predicate matches the current node being processed.
          Let's add another model and give it a predicate:</para>
        <figure>
          <title>Distinguish places and people</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen5.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="name" mode="change"&gt;
    &lt;model predicate="@type='place'" behaviour="inline"&gt;
        &lt;outputRendition &gt;
        color: #0077FF;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
    &lt;model behaviour="inline"&gt;
        &lt;outputRendition&gt;
        color: #FF9900;
        &lt;/outputRendition&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <note>
          <title>Important</title>
          <para>The order of models within the element spec is important. If you move the model with
            the predicate to the bottom, all names will appear in the same color again. This happens
            because the processor walks through the models until it finds the first one matching the
            current node. If the model without predicate is first, it will always win over the one
            with the predicate!</para>
          <para>Also, if there's more than one matching model, only the first will be chosen.</para>
        </note>
      </section>
      <section>
        <title>Parameters</title>
        <para>All behaviours accept one or more parameters which are defined in the TEI guidelines.
          Every behaviour has an implicit parameter called <parameter>content</parameter>, and, as
          the name suggests, it specifies which part of the source document should be processed: by
          default it uses the nested content of the node. You may overwrite this default and assign
          it another value. Some behaviours take other specialized parameters. For example, the
            <parameter>alternate</parameter> behaviour accepts two parameters:
            <parameter>default</parameter> and <parameter>alternate</parameter>. An alternate
          switches between two alternative states. On the web this could take the form of a popup,
          in print it is usually implemented as a footnote.</para>
        <para>To put this to a test, let's look at the <tag>date</tag> elements appearing within the
          letter. Most of them also specify a normalized date in their <parameter>@when</parameter>
          attribute. Seeing this may be helpful for the reader, for example, to know that the
            <parameter>19th</parameter> mentioned in the postscript refers to
            <parameter>1957-12-19</parameter>. However, we may want to present the normalized date
          in a more readable way. XPath has a function <function>format-date</function> for the
          purpose and we could use it to show a representation of the date nicely formatted in the
          user's language.</para>
        <para>Add a new element spec for <tag>date</tag>. You'll already see 4 predefined models.
          The first two are for print only, but the third one does indeed use behaviour
            <function>alternate</function>, which is exactly what we want. Change the parameter
          value for <parameter>alternate</parameter> to format the date:</para>
        <figure>
          <title>Format the normalized date in <parameter>@when</parameter>
          </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="editor-screen6.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="date" mode="change"&gt;
    &lt;model output="print" predicate="text()" behaviour="inline"/&gt;
    &lt;model output="print" predicate="@when and not(text())" behaviour="inline"&gt;
        &lt;param name="content" value="@when"/&gt;
    &lt;/model&gt;
    &lt;model output="web" predicate="@when" behaviour="alternate"&gt;
        &lt;param name="default" value="."/&gt;
        &lt;param name="alternate" value="format-date(@when, '[FNn], [D1o] [MNn], [Y]')"/&gt;
    &lt;/model&gt;
    &lt;model predicate="text()" behaviour="inline"/&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>
      <section>
        <title>Screencast</title>
        <para>The screencast below recapitulates some of the modifications we just applied. It uses
          an older version of TEI Publisher, but the basic concepts and controls are still the
          same:</para>
        <figure xml:id="edit-odd">
          <title>Screencast</title>
          <mediaobject>
            <videoobject>
              <videodata fileref="https://www.youtube.com/embed/avRO-b2BwUI?rel=0" width="853"
                depth="480"/>
            </videoobject>
          </mediaobject>
        </figure>
      </section>
      <section xml:id="oddxml">
        <title>Edit the ODD XML by hand</title>
        <para>To switch to the XML source code of the currently edited ODD from within the visual
          editor, click on the button with the angle brackets in the toolbar of the left side panel.
          If you made changes in the form, you need to save first to update the ODD. The ODD XML
          will be opened in a new tab, showing eXist's browser-based editor, <emphasis role="bold"
            >eXide</emphasis>.</para>
        <para>While using <emphasis role="bold">eXide</emphasis> is sufficient for small edits, we
          really recommend using specialized XML editor like <emphasis role="bold">oXygen</emphasis>
          for serious work on your TEI files. It will help you with many tasks, starting with the
          syntax and documentation. You can edit ODDs stored in eXist using Oxygen's
            <emphasis>webdav</emphasis> support or the <emphasis>eXist data source</emphasis>
          function.</para>
        <note>
          <title>Important</title>
          <para>If you edit the ODD XML by hand, there are some caveats you need to be aware of: the
            visual editor will automatically check if there are existing <tag>elementSpec</tag>s for
            a new element in any of the ODDs your ODD inherits from. When editing by hand, you need
            to do this yourself. It's best to always have the base ODDs: <link
              xlink:href="odd/tei_simplePrint.odd" role="source">
              <filename>tei_simplePrint.odd</filename>
            </link> and <link xlink:href="odd/teipublisher.odd" role="source">
              <filename>teipublisher.odd</filename>
            </link> open on the side. Both are located in the same collection as your odd, i.e.
              <filename>/db/apps/tei-publisher/odd</filename>.</para>
          <para>For example, to modify the element spec for <tag>dateline</tag>, check
              <filename>tei_simplePrint.odd</filename>, where you'll find a definition already. Copy
            it over to your ODD and start modifying it.</para>
          <para>Pay attention to the <option>@mode</option> attribute on <tag>elementSpec</tag>. You
            must set this to <parameter>change</parameter> if you are overwriting an elementSpec
            which already exists in the inherited ODDs. If not, set it to
            <parameter>add</parameter>.</para>
        </note>
        <para>To test any changes, switch back to the tab in which you viewed your document (e.g.
          Graves' letter) and select <guibutton>Admin</guibutton> / <guibutton>Recompile
            ODD</guibutton> from the menu.</para>
      </section>
    </section>

    <section xml:id="pm-syntax">
      <title>Processing Model Syntax</title>
      <para>TEI gives users a lot of freedom: there's always more than one way to encode your
        material! To maintain interoperability and sustainability, you need a way to formally
        describe the schema used as well as document editorial guidelines and transcription
        processes. TEI ODD was designed for the purpose of expressing all this in the TEI language
        itself. But how a document should be rendered was previously still considered to be the
        responsibility of external publishing software and could not be described within the
        ODD.</para>
      <para>The advent of the TEI Processing Model changed this! The intended processing for all
        elements can now be expressed within the TEI vocabulary as part of the ODD thus fulfilling
        its promise of <emphasis role="bold">One Document Does It All</emphasis>. Markup elements
        are mapped to a small set of abstract transformation functions, called <emphasis role="bold"
          >behaviours</emphasis>. Basic styling features can be set directly within the ODD using
        CSS. The processing model is media-agnostic: behaviours and rendition styles are
        transparently translated into different output media types like HTML, XSL-FO, LaTeX, or
        ePUB. A single ODD can handle a multitude of output media types with just a few small
        adjustments.</para>
      <section>
        <title>
          <tag>model</tag> element</title>
        <para>
          <tag>model</tag> element is primarily used to document intended processing for a given
          element. One or more of these elements may appear directly within an
            <tag>elementSpec</tag> element specification to define the processing anticipated for
          that element. Where multiple <tag>model</tag> elements appear, they are understood to
          document mutually exclusive processing scenarios, possibly for different outputs or
          applicable in different contexts. </para>
        <para>A processing model defines on an abstract level how a given element may be transformed
          to produce one or more outputs. The model is expressed in terms of <emphasis role="bold"
            >behaviours</emphasis> and their parameters, using high-level formatting concepts, such
          as <parameter>block</parameter>, <parameter>inline</parameter>,
            <parameter>note</parameter> or <parameter>heading</parameter>. A processing model is
          thus a template description, used to generate the code needed by the publishing
          application to process the source document into required output. </para>
        <para>Example below depicts a situation where a single model is defined for <tag>app</tag>
          element. As no <parameter>@predicate</parameter> or <parameter>@output</parameter> are
          specified, this model applies for all contexts in which <tag>app</tag> may appear and all
          possible outputs. Thus all <tag>app</tag> elements will be transformed into inline chunks
          of text containing only contents of <tag>app</tag>'s <tag>lem</tag> child and omitting any
          possible <tag>rdg</tag> children.</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="app"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;param name="content" value="lem"/&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
        <section>
          <title>
            <tag>model</tag> children and attributes:</title>
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <parameter>@predicate</parameter>: the condition under which this model applies,
                  given as an XPath Predicate Expression</para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@behaviour</parameter>: names the function which this processing model
                  uses in order to produce output; possible values include: alternate, block,
                  figure, heading, inline, link, list, note, paragraph</para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@output</parameter>: identifier of the intended output for which this
                  model applies; applies to all output if no @output is present on a
                    <tag>model</tag>
                </para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@useSourceRendition</parameter>: whether to obey any rendition
                  attribute which is present in the source document</para>
              </listitem>
              <listitem>
                <para>
                  <parameter>@cssClass</parameter>: one or more CSS class names which should be
                  added to the resulting output element where applicable</para>
              </listitem>
              <listitem>
                <para>
                  <tag>param</tag>: allows to pass parameters to @behaviour function; parameters
                  available depend on the behaviour in question; when parameters are not explicitly
                  passed, default values for those are assumed; all behaviour functions use current
                  element as default content</para>
              </listitem>
              <listitem>
                <para>
                  <tag>outputRendition</tag>: supplies information about the desired output
                  rendition in CSS; its attribute @scope provides a way of defining
                  ‘pseudo-elements’ eg: first-line, first-letter, before, after </para>
              </listitem>
            </itemizedlist>
          </para>
          <para>Simple model explicitly specifying content parameter: for <tag>app</tag> entries
            only content of its <tag>lem</tag> child is to be displayed (as an inline chunk of
            text):</para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="app"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;param name="content" value="lem"/&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para>Model specifying output rendition: contents of <tag>ex</tag> elements are to be
            displayed in italic and wrapped in parentheses:</para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="ex"&gt;
  &lt;model behaviour="inline"&gt;
    &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
    &lt;outputRendition scope="before"&gt;
      content:"(";&lt;/outputRendition&gt;
    &lt;outputRendition scope="after"&gt;content:")";&lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para>Sometimes different processing models are required for the same element in different
            contexts. For example, we may wish to process the <tag>quote</tag> element as an inline
            italic element when it appears inside a <tag>p</tag> element, but as an indented block
            when it appears elsewhere. To achieve this, we need to change the specification for the
              <tag>quote</tag> element to include two <tag>model</tag> elements as follows:</para>
          <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="quote"&gt;
  &lt;model predicate="ancestor::p" behaviour="inline"&gt;
    &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
  &lt;/model&gt;
  &lt;model behaviour="block"&gt;
    &lt;outputRendition&gt;
      left-margin: 2em;
    &lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
          <para>The first processing model will be used only for <tag>quote</tag> elements which
            match the XPath expression given as value for the <parameter>@predicate</parameter>
            attribute. Other element occurrences will use the second processing model. Set of
            multiple <tag>model</tag> statements is regarded as an alternation and only the first
            model with <parameter>@predicate</parameter> matching current context is applied.</para>
        </section>
        <section xml:id="model-styling">
          <title><tag>model</tag> output styling</title>
          <para>The intended rendering for a particular behaviour of a processing model may be
            specified in one or all of the three following ways.</para>

          <itemizedlist>
            <listitem>
              <para>the <parameter>@cssClass</parameter> attribute may be used to specify the name
                of a CSS style in an associated CSS stylesheet (read more on <link
                  linkend="external-css">specifying CSS styles in the ODD</link>) which is to be
                applied to each occurrence of a specified element found (in a given context, for a
                specified output),</para>
            </listitem>
            <listitem>
              <para>the attribute <parameter>@useSourceRendition</parameter> may be used to indicate
                that the rendition specified in the source document should be applied, </para>
            </listitem>
            <listitem>
              <para>the styling to be applied may be specified explicitly as content of a child
                  <tag>outputRendition</tag> element. </para>
            </listitem>
          </itemizedlist>
          <para> When more than one of these options is used, they are understood to be combined in
            accordance with the rules for multiple declaration of the styling language used. </para>
          <para> It is strongly recommended that use <tag>outputRendition</tag> should be limited to
            strictly editorial decisions, such as 'conjectures are to be displayed in square
            brackets' and not as means to record all typesetting and layout specific design choices.
            The latter are discussion in the <link linkend="css-styling">Custom CSS styling</link>
            chapter.</para>
          <para>The processing model library translates the CSS styles into the target media format.
            Restrictions apply due to differences between the output formats. Not all CSS properties
            are supported for every format. Please refer to the section on <link
              linkend="output-media">Output media settings</link> for further information.</para>


        </section>
      </section>
      <section>
        <title>
          <tag>modelSequence</tag> and <tag>modelGrp</tag>
        </title>
        <para> Summary of elements that can be used to document one or more processing models for a
          given element: <itemizedlist>
            <listitem>
              <para>
                <tag>model</tag> describes the processing intended for a specific context </para>
            </listitem>
            <listitem>
              <para>
                <tag>modelSequence</tag> (sequence of processing models) a group of model elements
                documenting intended processing models for this element, to be acted upon in
                sequence </para>
            </listitem>
            <listitem>
              <para>
                <tag>modelGrp</tag> (processing model group) a group of model elements documenting
                intended processing models for this element </para>
            </listitem>
          </itemizedlist>
        </para>
        <para> The <tag>modelGrp</tag> element may be used to group alternative <tag>model</tag>
          elements intended for a single kind of output. The <tag>modelSequence</tag> element is
          provided for the case where a sequence of models is to be processed, functioning as a
          single unit. Common use case would be to use modelSequence to generate table of contents
          along with the reading text as shown in the example below:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="body"&gt;
  &lt;modelSequence&gt;
    &lt;model behaviour="index"&gt;
      &lt;param name="type" value="'toc'"/&gt;
    &lt;/model&gt;
    &lt;model behaviour="block"/&gt;
  &lt;/modelSequence&gt;
&lt;/elementSpec&gt;</programlisting>
      </section>

      <section>
        <title>Behaviours</title>
        <para>The <link xlink:show="new"
            xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-model.html">TEI
            guidelines</link> document a number of default behaviours. TEI Publisher allows users to
          add their own behaviours, either within the ODD itself or by writing <link
            linkend="extension-modules">XQuery code</link>. The following section lists the default
          behaviours.</para>
        <section>
          <title>Available Behaviours</title>
          <para>Behaviour functions accept a range of parameters, depending on the function in
            question. Where these parameters are left unspecified in the <tag>model</tag>, default
            values are used. All functions take at least one parameter:
              <parameter>content</parameter>. It will be added by default unless specified and
            contains the nested content of the currently processed node. You may change this by
            explicitely setting a <parameter>content</parameter> parameter inside the model.</para>
          <para>In the parameter lists below we skip the <parameter>content</parameter> parameter as
            it is available for every behaviour. Optional parameters are marked as
              <emphasis>optional</emphasis> in parenthesis, followed by the output mode they apply
            for, if relevant.</para>
          <variablelist>
            <varlistentry>
              <term>alternate</term>
              <listitem>
                <para>Display alternating elements for displaying the preferred version and an
                  alternative, both at once or by some method of toggling between the two. The
                  concrete implementation depends on the output format.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>default</td>
                      <td>the content to display by default</td>
                    </tr>
                    <tr>
                      <td>alternate</td>
                      <td>alternate content</td>
                    </tr>
                    <tr>
                      <td>persistent</td>
                      <td>(optional, web) show a persistent popup on click instead of a tooltip on
                        hover if parameter evaluates to an effective boolean value of true</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>anchor</term>
              <listitem>
                <para>Create an anchor to which you can link, identified by the given id.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>id</td>
                      <td>the id</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>block</term>
              <listitem>
                <para>Create a block structure, usually a div in HTML or fo:block in fo.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>body</term>
              <listitem>
                <para>Create the body of a document. In HTML this will result in a &lt;body&gt;
                  tag.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>break</term>
              <listitem>
                <para>Create a line, column, or page break according to type.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>type</td>
                      <td>e.g. "page", "column", "line"</td>
                    </tr>
                    <tr>
                      <td>label</td>
                      <td>e.g. "p. 13v"</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>cell</term>
              <listitem>
                <para>Create a table cell. If the @cols or @rows attribute is specified, the cell
                  may span several columns/rows.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>cit</term>
              <listitem>
                <para>Show a citation, with an indication of the source.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>source</td>
                      <td>the citation source</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>document</term>
              <listitem>
                <para>Start a new output document.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>figure</term>
              <listitem>
                <para>Make a figure with provided title argument as caption</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>title</td>
                      <td>a caption</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>graphic</term>
              <listitem>
                <para>Display the graphic retrieved from the given url.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>url</td>
                      <td>the url to load the graphic from</td>
                    </tr>
                    <tr>
                      <td>width</td>
                      <td>the width of the graphic, e.g. "300px", "50%" ...</td>
                    </tr>
                    <tr>
                      <td>height</td>
                      <td>the height of the graphic, e.g. "300px", "50%" ...</td>
                    </tr>
                    <tr>
                      <td>scale</td>
                      <td>a scaling factor to apply. If specified, width and height will be output
                        as percentage based on the scaling factor, which should be a number between
                        0 and 1.</td>
                    </tr>
                    <tr>
                      <td>title</td>
                      <td>a title for the graphics element. Usually not shown directly.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>heading</term>
              <listitem>
                <para>Creates a heading.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>level</td>
                      <td>the structural level of this heading. In HTML mode, this translates to
                        &lt;h1&gt;, &lt;h2&gt; etc.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>inline</term>
              <listitem>
                <para>Outputs an inline element.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>link</term>
              <listitem>
                <para>Create a hyperlink.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>uri</td>
                      <td>the link url</td>
                    </tr>
                    <tr>
                      <td>target</td>
                      <td>identifier of the tab to open the link in (only web output)</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>list</term>
              <listitem>
                <para>Creates an ordered or unordered list, depending on the type attribute (e.g.
                    <parameter>type="ordered"</parameter>). If a label is present before each item,
                  a description list is output instead, using the label as definition term.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>type</td>
                      <td>The type of list: use "ordered" for an enumerated list, or "custom" to
                        specify item labels in combination with the <option>n</option> parameter on
                        each <command>listItem</command>. The default is "unordered" for a list of
                        bullet points.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>listItem</term>
              <listitem>
                <para>Outputs an item in a list.</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>n</td>
                      <td>a label to use for the item</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>metadata</term>
              <listitem>
                <para>Outputs a metadata section, e.g. a &lt;head&gt; in HTML.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>note</term>
              <listitem>
                <para>create a note, often out of line, depending on the value of
                  <code>place</code>; could be "margin", "footnote", "endnote", "inline"</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>place</td>
                      <td>defines the placement of the note, e.g. "margin", "footnote" ...</td>
                    </tr>
                    <tr>
                      <td>label</td>
                      <td>the label to use for the footnote reference, usually a number.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>omit</term>
              <listitem>
                <para> Do nothing, skip this element, do not process children </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>paragraph</term>
              <listitem>
                <para> Create a paragraph. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>row</term>
              <listitem>
                <para> Create a table row. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>section</term>
              <listitem>
                <para>Create a new section in the output document. In HTML mode, this translates to
                  a &lt;section&gt; element being output.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>table</term>
              <listitem>
                <para>Create a table.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>text</term>
              <listitem>
                <para>Output literal text.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>title</term>
              <listitem>
                <para>Output the document title. In HTML mode, this creates a &lt;title&gt; element.
                  In LaTeX, it adds the title to the document metadata.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>webcomponent (TEI Publisher extension)</term>
              <listitem>
                <para>Outputs a custom HTML element (usually referencing a webcomponent) using the
                  value of parameter <parameter>name</parameter> as tag name. All other parameters
                  are copied into corresponding attributes (properties of the webcomponent).</para>
                <informaltable>
                  <thead>
                    <tr>
                      <td>Parameter</td>
                      <td>Description</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>name</td>
                      <td>the tag name to use for the custom element. Must be a string value.</td>
                    </tr>
                  </tbody>
                </informaltable>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

    </section>

    <section xml:id="external-css">
      <title>Including General CSS Styles</title>
      <para>TEI Publisher is based on webcomponents, therefore styling of one document will not
        interfere with the styling of another document on the same page. All styles are strictly
        encapsulated within the component and do not "pollute" the global browser space. This also
        has a downside though: CSS rules defined outside the <tag>pb-view</tag> have no influence on
        the text styling inside the component (with some exceptions, mainly for properties which are
        inherited down the HTML tree, e.g. <parameter>font-family</parameter>).</para>
      <para>However, putting <emphasis>all</emphasis> styling information into
          <tag>outputRendition</tag> tags within the ODD is also not a good idea - it adds a lot of
        redundancy and mixes editorial responsibilities with web design concerns.</para>
      <para>Recommended solution would therefore be to use CSS classes for repeating styling
        aspects. TEI Publisher supports linking to an external CSS stylesheet from the
          <code>encodingDesc/tagsDecl/rendition</code> section of the ODD. Just specify a relative
        link in the <parameter>@source</parameter> attribute:</para>
      <programlisting language="xml" xml:space="preserve">
                  &lt;rendition source="docbook.css"/&gt;
          </programlisting>
      <para>The file should be stored in the same collection as the source ODD it is referenced
        from. The linked file should be a standard CSS stylesheet.</para>
      <para>Note that unfortunately, editing renditions is not yet supported by the visual ODD
        editor, so you will have to fall back to add the corresponding elements to the ODD by
        hand.</para>
      <para>Alternatively, one may also use the same TEI element <tag>rendition</tag> with the
          <parameter>@selector</parameter> attribute to embed CSS rules directly in the ODD.</para>

      <programlisting language="xml" xml:space="preserve">&lt;rendition selector="h3">
  font-family: serif;
  font-weight: 400;
&lt;/rendition></programlisting>
      <para>Choose one of the two approaches, but do not mix them. In both cases make sure to
        recompile the ODD after changes as the CSS is merged into the generated code!</para>

      <para>New addition in Publisher 6.0 allows to pass the external CSS file in
          <code>load-css</code> attribute of <code>pb-view</code>. Recompiling ODD in this case is
        not necessary, otherwise it is functionally equivalent to using ODD
        <code>rendition</code>.</para>
    </section>

    <section xml:id="output-media">
      <title>Output Media Settings</title>
      <para>The library supports various output media formats and translates styles into the
        corresponding format. Currently the following output modes are supported and can be used in
        the <parameter>@output</parameter> attribute:</para>
      <variablelist>
        <varlistentry>
          <term>web</term>
          <listitem>
            <para>Produces HTML output</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>fo</term>
          <listitem>
            <para>Generates a PDF via XSL:FO</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>latex</term>
          <listitem>
            <para>Creates a PDF via LaTeX</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>print</term>
          <listitem>
            <para>An alias which applies to both: fo and latex modes.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>epub</term>
          <listitem>
            <para>Similar to web concerning features, but targetted at epub documents</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The quality of the generated output may vary a lot for the fo and latex modes, depending
        on the type of input document. The following section provides more details on the
        configuration of the FO output option:</para>
      <section>
        <title>FO Output</title>
        <para>When generating XSL:FO output, the implementation tries to translate the CSS rules
          specified for renditions into the corresponding XSL:FO formatting properties. Not all CSS
          properties are recognized or can be mapped to FO properties. Unknown properties defined in
          a rendition will be ignored.</para>
        <para>The default rendering for headings, paragraphs and the like is defined by a separate
          CSS file. The implementation merges those defaults with the custom renditions given in the
          ODD.</para>
        <para>The library searches for default CSS styles in a file named
            <filename>&lt;odd-name&gt;.fo.css</filename> inside the specified output collection (in
          which the generated XQuery files are stored). The style definitions are copied literally
          into attributes on the output XSL:FO elements, so any property which is a valid attribute
          for the corresponding element may be used. For example,
            <filename>teipublisher.fo.css</filename> contains:</para>
        <programlisting language="css" xml:space="preserve">
.tei-text { font-family: "Junicode"; hyphenate: true; }
.tei-floatingText { padding: 6pt; }
.tei-p { text-align: justify; }
        </programlisting>
        <para>Every XSL:FO document needs a master layout and a page sequence definition. Because
          those tend to be rather verbose as they include things like page margins etc., they are
          read from two XML files:</para>
        <variablelist>
          <varlistentry>
            <term>master.fo.xml</term>
            <listitem>
              <para>Contains the layout master set</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>page-sequence.fo.xml</term>
            <listitem>
              <para>Defines the main page sequence</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>The mechanisms for configuring FO output are still very much under development and we
          welcome suggestions by users.</para>
      </section>
      <section>
        <title>LaTeX Output</title>
        <para>The latex output mode produces good results for longer texts which fit well into the
          pre-defined LaTeX environments. The number of supported CSS properties is limited
          though:</para>
        <itemizedlist>
          <listitem>
            <para>font-weight</para>
          </listitem>
          <listitem>
            <para>font-style</para>
          </listitem>
          <listitem>
            <para>font-variant</para>
          </listitem>
          <listitem>
            <para>font-size</para>
          </listitem>
          <listitem>
            <para>color</para>
          </listitem>
          <listitem>
            <para>text-decoration</para>
          </listitem>
          <listitem>
            <para>text-align</para>
          </listitem>
          <listitem>
            <para>text-indent</para>
          </listitem>
        </itemizedlist>
        <para>To create arbitary complex LaTeX output, you may want to use the <link
            linkend="pb-template"><tag>pb-template</tag> extension</link> to the ODD syntax. It is
          heavily used to e.g. generate the LaTeX version of this documentation. See also <link
            xlink:href="odd/serafin.odd" role="source">serafin.odd</link> or <link
            xlink:href="odd/vangogh.odd" role="source">vangogh.odd</link> for examples.</para>
        <para>TEI Publisher creates a default LaTeX prolog based on standard packages and settings.
          You may overwrite the defaults by providing your own template within the ODD element spec
          for the TEI root element. See the example ODDs mentioned above. Note that TEI Publisher
          will generate some LaTeX macros for styles defined in <tag>outputRendition</tag> which
          should be imported into the prolog. The styles are added to the default configuration map
          and can be accessed via <command>$config('latex-styles')</command>. Refer to the example
          ODDs and just copy/paste the corresponding lines.</para>
        <para>This output mode requires a local installation of LaTeX on the machine running TEI
          Publisher. The examples have been tested on a default installation of MacTeX 2018. If you
          are not running MacTeX, you likely need to adjust the path to the LaTeX binary in the
          XQuery configuration module <filename>modules/config.xqm</filename>. Search for the
          variable <parameter>$config:tex-command</parameter> and adjust it to point to a binary of
            <command>xelatex</command>, <command>pdflatex</command> or
          <command>lualatex</command>.</para>
      </section>
      <section>
        <title>ePub Output</title>
        <para>The <parameter>epub</parameter> output mode extends the HTML mode. You may define
          general styling in an extra CSS file, located in
            <filename>resources/css/epub.css</filename>. This external stylesheet is included into
          all generated epub files and may be used to configure general settings like page breaks,
          hyphenation, font sizes etc.</para>
      </section>
    </section>


    <section>
      <title>Extensions to the Processing Model Specification</title>
      <section>
        <title>XQuery Instead of XPath</title>
        <para>The implementation directly translates processing model instructions into an XQuery
          3.1 module by generating executable XQuery code. This is straightforward as the resulting
          XQuery will closely resemble the specification in the ODD, thus being easy to debug. It
          also leads to very efficient code, which is as fast or even faster as a hand-written,
          optimized transformation.</para>
        <para>As a welcome side effect, any valid XQuery expression might be used wherever the spec
          expects an XPath expression, e.g. in predicates or parameters. For example, one can define
          variables inside a parameter using a standard XQuery <code language="xquery">let $x := ...
            return ...</code> syntax.</para>
      </section>
      <section>
        <title>Default Processing Model Rules</title>
        <para>It is possible to define a default <tag>elementSpec</tag> to be applied to all
          elements which are not already matched by another elementSpec. For example, if no
            <tag>elementSpec</tag> is present for an element, its text content is output. To change
          this behaviour and omit content elements without specification, you may want to define a
          default <tag>elementSpec</tag> as shown below:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="*"&gt; &lt;model behaviour="omit"/&gt; &lt;/elementSpec&gt;</programlisting>
        <para>You can also define models to be applied to all text nodes, e.g. if you need to
          normalize certain nodes:</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec ident="text()"&gt;
  &lt;model behaviour="text"/&gt;
&lt;/elementSpec&gt;</programlisting>
        <para>Note that outputting text nodes is a performance critical operation, so use with care.
          Too complex processing will likely slow down rendering dramatically.</para>
      </section>
      <section xml:id="external-parameters">
        <title>External Parameters</title>
        <para>The script calling the processing model may pass external parameters into the ODD.
          They will be available in the variable <parameter>$parameters</parameter>, which is an
          XQuery map. Access parameters using the XQuery lookup operator.</para>
        <para>For example, one can use this feature to control how specific parts of the document
          are output, without having to define a separate output mode, which would result in much
          more code. Below we display a shortened header for the document, containing simply its
          title, but only if the parameter "header" is set to "short":</para>
        <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="fileDesc"&gt;
    &lt;model predicate="$parameters?header='short' behaviour="block" cssClass="header-short"&gt;
      &lt;param name="content" value="titleStmt"/&gt;
    &lt;/model&gt;
  ...
&lt;/elementSpec&gt;</programlisting>
        <para>The <tag>pb-view</tag> webcomponent also lets you define arbitrary parameters to be
          passed to the ODD via <tag>pb-param</tag>. For example, the breadcrumbs shown above this
          documentation page are realized by setting a parameter <parameter>mode</parameter> and can
          be queried in model predicates with
          <parameter>$parameters?mode='breadcrumbs'</parameter>.</para>
        <programlisting language="xml" xml:space="preserve">&lt;section class="breadcrumbs"&gt;
    &lt;pb-view id="title-view1" src="document1" subscribe="transcription"&gt;
        &lt;pb-param name="mode" value="breadcrumbs"/&gt;
    &lt;/pb-view&gt;
&lt;/section&gt;</programlisting>
        <para>If the parameter is set, the processing model rules in the ODD will output the
          headings of all ancestor sections of the current division only, ignoring everything else.
          This approach helps to reuse the same ODD for viewing specific aspects of the
          document.</para>
        <para>A dedicated user interface webcomponent <link xlink:show="new"
            xlink:href="../../pb-components-api/index.html#/elements/pb-toggle-feature/demos/demo/pb-toggle-feature.html"
              ><tag>pb-toggle-feature</tag></link> exists for toggling between two values of a
          parameter. Example below would produce a checkbox which when on results in the value of
            <parameter>$parameters?mode</parameter> set to <parameter>diplomatic</parameter>,
          otherwise to <parameter>norm</parameter>. </para>
        <programlisting language="xml" xml:space="preserve">&lt;pb-toggle-feature name="mode" on="diplomatic" off="norm"&gt;Diplomatic View&lt;/pb-toggle-feature&gt;</programlisting>
      </section>
      <section>
        <title>Code Templates and Custom Behaviours</title>
        <para>The two dozen behaviours defined by the TEI processing model are enough to cover most
          HTML output tasks, but other output formats like LaTeX may require more customization and
          control over the generated output. The TEI Publisher library thus extends the processing
          model syntax with two custom elements for defining code templates.</para>
        <para>While TEI Publisher does provide ways to write your own behaviours in XQuery and thus
          extend the ones defined in the guidelines, this should only be used as last resort: custom
          XQuery behaviours limit the portability of the ODD and are bad for maintenance.</para>
        <para>Avoiding custom behaviours works quite well for HTML output and we have realized
          complex projects with just two or three extension behaviours. Things start to become more
          difficult if you try to output LaTeX though: there are hundreds of packages to use, and
          users typically define their own macros or environments for all recurring typesetting
          tasks. For example, to print a TEI <tag>persName</tag>, experienced LaTeX users would
          normally create a corresponding <code>\persName</code> macro and handle the formatting
          details there. Unfortunately, out of the box the TEI processing model does not facilitate
          this level of customization.</para>
        <section xml:id="pb-template">
          <title>Introducing <tag>pb:template</tag>
          </title>
          <para>TEI Publisher thus supports an extension to the ODD syntax in its own namespace
              (<parameter>http://teipublisher.com/1.0</parameter>).</para>
          <para> Within the ODD, a <tag>model</tag> may define a <tag>pb:template</tag> element
            containing a code template. The template is expanded first and the result is passed into
            the behaviour specified for the model, replacing the default
              <parameter>content</parameter> parameter accepted by all behaviours. The very simple
            case of outputting a <tag>persName</tag> in LaTeX could thus be written as:</para>

          <programlisting language="xml" xml:space="preserve"><![CDATA[<elementSpec ident="persName" mode="add">
    <model behaviour="inline" output="latex">
        <pb:template>\persName{[[content]]}</pb:template>
    </model>
</elementSpec>]]></programlisting>
          <para>The template can reference other parameters defined within the <tag>model</tag> by
            enclosing the parameter name in double brackets. In the example above we're referencing
            the default parameter <parameter>content</parameter>, which contains the nested content
            of the <tag>persName</tag> tag. The parameter will be processed before it is passed into
            the template, so if <tag>persName</tag> contains nested TEI markup, the corresponding
            processing model rules will be applied first.</para>
          <para>The result of expanding the template then becomes the new
              <parameter>content</parameter> parameter to be passed to the behaviour
              (<code>inline</code> in the example above), which is processed in the normal way as
            defined in the TEI guidelines.</para>
          <para>You may also specify additional parameters to be included in the template. For
            example, the TEI document may contain a glossary of terms which are referenced in the
            text using <code>&lt;term ref="#termid"&gt;text&lt;/term&gt;</code>. In LaTeX this would
            translate to <code>\glslink{ref}{text}</code>, which can be easily produced by the
            following <tag>model</tag>:</para>
          <programlisting language="xml" xml:space="preserve"><![CDATA[<elementSpec ident="term" mode="add">
    <model behaviour="inline" output="latex">
        <param name="ref" value="substring-after(@ref, '#')"/>
        <pb:template>\glslink{[[ref]]}{[[content]]}</pb:template>
    </model>
</elementSpec>]]></programlisting>
          <para>We define an additional parameter <parameter>ref</parameter>, which contains the id
            string from the <parameter>@ref</parameter> attribute, stripping out the leading
            '#'.</para>
          <para>The templating mechanism is not limited to LaTeX, but may also be used to generate
            HTML or FO, for example, if you have to generate a complex HTML fragment to represent a
            single TEI element. This is hard and sometimes impossible to achieve without templates.
            We'll see some examples in the next section.</para>
        </section>
      </section>
      <section xml:id="pb-behaviour">
        <title>Defining New Behaviours in the ODD</title>
        <para>By combining code templates with parameters we can come up with a very simple
          mechanism to define new behaviours right inside the ODD!</para>
        <para>Take the TEI Publisher documentation as an example: it is written in docbook 5 and
          transformed via ODD. The documentation includes some videos which are hosted on youtube.
          In docbook those are represented by <tag>videodata</tag> elements inside a
            <tag>videoobject</tag>:</para>
        <programlisting xml:space="preserve"><![CDATA[<figure xml:id="edit-odd">
    <title>Screencast</title>
    <mediaobject>
      <videoobject>
        <videodata fileref="https://www.youtube.com/embed/avRO-b2BwUI?rel=0" width="853" depth="480"/>
      </videoobject>
    </mediaobject>
</figure>]]></programlisting>
        <para>In the HTML output we would need to transform this into an <tag>iframe</tag>, so the
          reader can view the video embedded in the page. We can achieve this with a
            <tag>pb:template</tag> as sketched in the previous section, but it would be nice to turn
          this into a general-purpose behaviour, which we can re-use in other situations requiring
          an iframe. The TEI Publisher library allows us to define a behaviour right inside the ODD
          as follows:</para>

        <programlisting xml:space="preserve"><![CDATA[<pb:behaviour ident="iframe" output="web">
    <pb:param name="src"/>
    <pb:param name="width"/>
    <pb:param name="height"/>
    <pb:template xmlns="">
        <iframe src="[[src]]" width="[[width]]" height="[[height]]" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen="allowfullscreen"></iframe>
    </pb:template>
</pb:behaviour>]]></programlisting>

        <note>
          <title>Note</title>
          <para>Note how we have to reset the namespace on the <tag>pb:template</tag>? This is
            required because the default namespace in an ODD document is the TEI namespace. You thus
            need to reset it whenever you want to output elements in another or no namespace inside
            a template. Without this, the iframe would end up in the TEI namespace. Webbrowsers will
            usually ignore it, but it will be wrong nevertheless.</para>
        </note>
        <para>All behaviours should be included in the TEI header or - to be exact: the
            <tag>tagsDecl</tag> inside the <tag>encodingDesc</tag>. You may have multiple behaviour
          declarations with the same <parameter>@ident</parameter>, given that they apply to
          different <parameter>@output</parameter> modes. Parameters specified via
            <tag>pb:param</tag> without <parameter>@value</parameter> attribute are expected to be
          passed to the behaviour from the calling model. A parameter may be empty though. If you
          define an XPath expression as <parameter>@value</parameter> attribute, the result of the
          XPath evaluation will be used as value for the parameter.</para>
        <para>The new behaviour will be named <function>iframe</function> and takes three
          parameters: <parameter>src</parameter>, <parameter>width</parameter> and
            <parameter>height</parameter>. It can now be called from a <tag>model</tag> as
          follows:</para>
        <programlisting xml:space="preserve"><![CDATA[<model behaviour="iframe">
    <param name="width" value="@width"/>
    <param name="height" value="@depth"/>
    <param name="src" value="@fileref"/>
</model>]]></programlisting>
        <para>For further code examples, please have a look at <link xlink:href="odd/docbook.odd"
            role="source">docbook.odd</link>, which is used for viewing the documentation.</para>
        <note>
          <title>Note</title>
          <para>At the time of writing, the graphical ODD editor in TEI Publisher does not yet
            support defining your own behaviours via <tag>pb-behaviour</tag>. You thus have to make
            those changes in the source XML using eXide, oXygen or another XML editor. You can,
            however, use the graphical editor to continue editing the ODD afterwards. It is smart
            enough to not overwrite your hand-written code upon save.</para>
        </note>
      </section>
    </section>

    <section xml:id="extension-modules">
      <title>Extension Modules</title>
      <para>Where possible, developers should stick to the standard behaviours defined by the TEI
        guidelines, or use the <tag>pb-behaviour</tag> and <tag>pb-template</tag>
        <link linkend="pb-behaviour">extensions</link> of the ODD syntax. However, there might be
        situations in which it is necessary to generate a specific type of complex output, which
        requires the full power of XQuery. To facilitate this, the implementation allows additional
        extension modules to be configured:</para>
      <section xml:id="extension-configuration">
        <title>Configuration</title>
        <para>Configuration is done via an XML file which must reside in the same collection as the
          source ODD files. It contains a series of <tag>output</tag> elements, representing
          particular output modes (e.g. web or print) via <parameter>@mode</parameter> attribute.
            <tag>output</tag> element without a mode groups modules available for all output
          modes.</para>
        <para>Each <tag>output</tag> element lists modules to be loaded for specified output mode.
          Each definition may optionally be limited to a specific ODD, name of which is specified in
          the <parameter>@odd</parameter> attribute.</para>
        <programlisting language="xml" xml:space="preserve">&lt;modules&gt;
    &lt;!-- functions or behaviours common to all output modes --&gt;
    &lt;output&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/common-functions" prefix="tc" at="xmldb:exist:///db/apps/my-app/modules/common.xql"/&gt;
    &lt;/output&gt;
    &lt;!-- General fo extension functions --&gt;
    &lt;output mode="print"&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/ext-fo" prefix="ext-fo" at="xmldb:exist:///db/apps/tei-publisher/modules/ext-fo.xql"/&gt;
    &lt;/output&gt;
    &lt;!-- Special web configuration for the documentation (to handle &lt;code&gt;) --&gt;
    &lt;output mode="web" odd="documentation"&gt;
      &lt;module uri="http://www.tei-c.org/tei-simple/xquery/ext-html" prefix="ext-html" at="xmldb:exist:///db/apps/tei-publisher/modules/ext-html.xql"/&gt;
    &lt;/output&gt;
&lt;/modules&gt;</programlisting>
        <para>Whenever the library tries to locate a processing model function for a given
          behaviour, it will <emphasis role="bold">first</emphasis> check any extension module it
          knows to see if it contains a matching function. One can thus <emphasis role="bold"
            >overwrite</emphasis> the default functions as well as define new ones.</para>
        <para>An extension module may also contain general purpose XQuery functions you want to call
          from within an ODD parameter, e.g. for formatting a date, outputting a number etc. To make
          those functions available to all output modes, just skip the <parameter>@mode</parameter>
          attribute.</para>
      </section>
      <section>
        <title>Implementing Custom Behaviours</title>
        <para>To be recognized by the library, an extension function must accept at least 4 default
          arguments, plus any number of custom parameters. The required parameters are:</para>
        <variablelist>
          <varlistentry>
            <term>$config</term>
            <listitem>
              <para>a map containing configuration information as well as function references to be
                called. The most important ones are <function>$config?apply($config,
                  $node)</function> and <function>$config?apply-children($config, $node,
                  $content)</function>. Both are function items and when called, continue processing
                with either a single <parameter>$node</parameter> or a sequence of nodes in
                  <parameter>$content</parameter>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>$node</term>
            <listitem>
              <para>the TEI element being processed at the moment</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>$class</term>
            <listitem>
              <para>a list of HTML class names to be used. This includes automatically generated
                class names as well as those passed via <parameter>@cssClass</parameter> on a model
                item.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>$content</term>
            <listitem>
              <para>because <parameter>content</parameter> is defined for every model rule, it is
                always passed to a behaviour function (though it might be empty)</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>For all additional parameters, the processing model implementation tries to fill each
          custom parameter with a corresponding value by looking through the <tag>param</tag>
          children of the <tag>model</tag> in the ODD to find one with a name matching the variable
          name. If no matching parameter can be found, the function argument will be set to the
          empty sequence. You should not enforce a type or cardinality for any of the custom
          parameters as this may lead to unexpected errors. The parameters may be empty or contain
          more than one item.</para>
        <para>For example, a custom behaviour called <code>code</code> for syntax highlighting in an
          extension module named <filename>ext-html.xql</filename> might look as follows:</para>
        <programlisting language="xquery" xml:space="preserve">xquery version "3.1";
(:~ : Non-standard extension functions, mainly used for the documentation. :)
module namespace pmf="http://www.tei-c.org/tei-simple/xquery/ext-html";
declare namespace tei="http://www.tei-c.org/ns/1.0";

declare function pmf:code($config as map(*), $node as element(), $class as xs:string+, $content as node()*, $lang as item()?) {
    &lt;pre class="code {$class}" data-language="{if ($lang) then $lang else 'xquery'}"&gt;
    {replace(string-join($content/node()), "^\s+?(.*)\s+$", "$1")}
    &lt;/pre&gt;
};</programlisting>
        <para>It defines one function, <function>pmf:code</function>, which can be called from the
          ODD as follows, provided that the <filename>ext-html.xql</filename> module has been
          configured as described in the <link linkend="extension-configuration">previous
            section</link>.</para>
        <programlisting language="xml" xml:space="preserve">
&lt;model behaviour="code"&gt; 
    &lt;param name="lang" value="@lang"/&gt; 
&lt;/model&gt;
        </programlisting>
      </section>
      <section>
        <title>Custom Behaviours Accepting User-Defined Parameters</title>
        <para>Sometimes you may like to implement a generic behaviour which takes arbitrary
          parameters from the user. This means the parameter list of your behaviour will not be
          fixed.</para>
        <para>To facilitate this, a behaviour function may declare a final parameter <code>$optional
            as map(*)</code>. If the processor finds <tag>param</tag> children in the model which
          cannot be mapped to an explicitly declared parameter, it stores all such extra parameters
          as a key/value pairs in the <parameter>$optional</parameter> map.</para>
      </section>
    </section>


    <section xml:id="odd-by-example">
      <title>Building a Sample-Based ODD</title>
      <para>If you do not want to start a customized ODD from a blank template, you can
        alternatively generate one that covers the classes and elements of a selection of TEI files
        stored in TEI Publisher's data collection. Simply select one or more sample documents in the
        list to the left, enter a name and title into the form and click on <guibutton>Create from
          examples</guibutton>. Note that if you haven't removed the default examples TEI files that
        shipped with tei-publisher their markup will be included in the constructed ODD as
        well.</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="BuildODD.gif"/>
        </imageobject>
      </mediaobject>
      <para>This method uses the <filename>oddbyexample.xsl</filename> stylesheet that is part of
        the TEI consortium's <link xlink:show="new" xlink:href="https://github.com/TEIC/Stylesheets"
          >stylesheets</link>. Users with a corpus of one or more TEI files can generate a custom
        odd that contains explicit additions and deletions for all possible TEI modules, as well as,
          <tag>valList</tag> for attribute values in the input corpus.</para>
      <para>By default the basis of the comparison for which elements have been modified in the
        examples is the full <filename>tei_all.odd</filename>.</para>
      <section>
        <title>Advanced Use</title>
        <para>To further tweak the building process you can call the functions of the
            <filename>odd-by-example.xql</filename> module from your own XQuery code. If you wish to
          generate your own basis for the comparison you can call the following function to store a
          compiled ODD in the default odd location of tei-publisher:</para>
        <programlisting language="XQuery" xml:space="preserve">obe:compile-odd(doc('../odd/my-file.odd'), 'my-file-name')</programlisting>
        <note>
          <title>Note</title>
          <para>Due to a bug in the <filename>odd2odd.xsl</filename> stylesheet the output of this
            function is not always valid. To use it for further processing you need to make sure
            that only valid documents are used for further processing</para>
        </note>
        <para>You can also modify the transformation parameters of:</para>
        <programlisting language="XQuery" xml:space="preserve">obe:process-example(doc('../data/test/myTEI.xml'), 'odd-name', 'simplePrint')</programlisting>
        <para>The above example uses simplePrint as a basis for building the new ODD. The full list
          of configurable options are:</para>
        <programlisting language="xml" xml:space="preserve">&lt;parameters&gt;
  &lt;!-- the document corpus --&gt;
  &lt;param name="corpus" value="."/&gt;
  &lt;!-- name of odd --&gt;
  &lt;param name="schema" value="{substring-before($output, '.odd')}"/&gt;
  &lt;!-- the source of the TEI (just needs *Spec)--&gt;
  &lt;param name="defaultSource" value="{$base}"/&gt;
  &lt;!-- should we make valList for @rend and @rendition --&gt;
  &lt;param name="enumerateRend" value="false"/&gt;
  &lt;!-- whether to do all the global attributes --&gt;
  &lt;param name="keepGlobals" value="true"/&gt;
  &lt;!-- should elements in teiHeader be included?--&gt;
  &lt;param name="includeHeader" value="true"/&gt;
  &lt;!-- should we make valList for @type --&gt;
  &lt;param name="enumerateType" value="true"/&gt;
  &lt;!-- should we deal with non-TEI namespaces --&gt;
  &lt;param name="processNonTEI" value="false"/&gt;
  &lt;!-- do you want moduleRef generated with @include or @except? --&gt;
  &lt;!-- seems broken see https://github.com/TEIC/Stylesheets/issues/212 --&gt;
  &lt;param name="method" value="include"/&gt;
  &lt;!-- turn on debug messages --&gt;
  &lt;param name="debug" value="false"/&gt;
  &lt;!-- turn on messages --&gt;
  &lt;param name="verbose" value="false"/&gt;
  &lt;!-- which files to look at? provide suffix --&gt;
  &lt;param name="suffix" value="xml"/&gt;
  &lt;!-- should P4 files be considered? --&gt;
  &lt;param name="processP4" value="false"/&gt;
  &lt;!-- should P5 files be considered? --&gt;
  &lt;param name="processP5" value="true"/&gt;
&lt;/parameters&gt;
          </programlisting>
      </section>
    </section>
  </section>

  <section xml:id="css-styling">
    <title>Custom CSS styling</title>

    <para>CSS stylesheet <code>resources/css/theme.css</code> defines styles used by all pages of
      the TEI Publisher and publisher-generated applications. Nevertheless, users <emphasis
        role="bold">should not</emphasis> directly modify this file but create a project-specific
      css customization file and include it alongside <code>theme.css</code> instead.</para>
    <programlisting language="html" xml:space="preserve">
                  &lt;link rel="stylesheet" href="resources/css/theme.css" /&gt;
                  &lt;link rel="stylesheet" href="resources/css/my-project.css" /&gt;
          </programlisting>
    <para>This approach allows to selectively overwrite certain styles and CSS variables from
        <code>theme.css</code> while remaining on the easy upgrade path for future TEI Publisher and
        <code>pb-components</code> updates.</para>

    <section>
      <title>Customizing web components styling</title>
      <para>A web component completely shields its content, so it cannot be styled from outside. Web
        component styles remain encapsulated, preventing style contamination between individual
        components and general application context. A blessing in general, allowing component to be
        scripted and styled without the fear of collision with other parts of the page, but poses
        additional challenges when adjusting look and feel of a component to fit project's
        theme.</para>
      <para>For Publisher, encapsulation of web components means that definitions in
          <code>theme.css</code> or equivalent project customization CSS file are not able to
        directly govern web components styling.</para>
      <para>While some aspects of component styling remained unaccessible for customization in
        versions preceding Publisher 6, currently <code>pb-components</code> expose style properties
        to the outside world via standard CSS variables. This way variables like
          <code>--pb-footnote-color</code> defined in <code>theme.css</code> can be accessed by e.g.
          <code>pb-view</code> component and thus determine the color of the footnote marker in the
        rendered transcription.</para>

      <para>Note that while you cannot change the inner appearance of a component except by setting
        its custom CSS properties, you can style the component itself within the HTML template, e.g.
        to position it within the layout of the page.</para>
    </section>
    <section>
      <title>External stylesheets</title>
      <para>ODD specification allows for explicit declaration of an external CSS file which may
        define styles and CSS classes to be applied to tranformed sources (in
          <code>encodingDesc/tagsDecl/rendition</code>), e.g.</para>
      <programlisting language="xml" xml:space="preserve">
                  &lt;rendition source="docbook.css"/&gt;
          </programlisting>
      <para>Styles and classes from that file are loaded into <code>pb-view</code> component and
        thus accessible for its content.</para>
      <para>External stylesheets for <code>pb-view</code> can also be specified via
          <code>load-css</code> component configuration attribute. In this scenario, unlike with ODD
          <code>rendition</code>, regenerating ODD is not required for changes to the CSS file to be
        applied, otherwise both methods are functionally equivalent.</para>

      <programlisting language="html" xml:space="preserve">
                  &lt;pb-view id="view1" src="document1" load-css="odd/docbook.css"/&gt;
          </programlisting>

      <para>Broader discussion of using <tag>rendition</tag> for custom styles can be found in <link
          linkend="external-css">this section</link>.</para>
      <!-- shall we discuss CSS shadow part? somewhere -->
    </section>
  </section>

  <section xml:id="webcomponents">
    <title>Page templates and pb-components</title>
    <para>As described earlier, the various sample documents included in the TEI Publisher Demo
      collection differ not only in the ODD they use, but also concerning the general layout and
      composition of the page. They are based on different HTML templates, which can be found in the
        <filename>templates/pages</filename> collection of the TEI Publisher app. Each template
      assembles various building blocks in a slightly different way - some <link
        linkend="selected-use-cases">examples</link> show a facsimile view next to the text, others
      a parallel display of transcription andtranslation, some include a map and another showcase
      collapsible metadata section. Which template is being used is determined by a <link
        linkend="pi-config">processing instruction</link> in the TEI sources of these
      examples.</para>
    <para>The building blocks we mentioned are custom HTML elements. Each of them encapsulates a
      certain functionality and appearance. The map, the facsimile, but also the text view itself
      and all controls are custom HTML elements. They are like "Lego" blocks which can be freely
      moved around and rearranged without knowing anything about internal implementation of the
      component.</para>
    <section>
      <title>Web Components</title>


      <para>The technology enabling this Lego-like modular approach is a W3C standard called
          <emphasis>Web Components</emphasis>. It is already built into many browsers and support is
        improving quickly, reducing the need for external frameworks. There's a growing collection
        of ready-to-use components available, e.g. the <link xlink:show="new"
          xlink:href="https://www.webcomponents.org/author/PolymerElements">Polymer elements</link>
        we use for menus, buttons, dropdowns etc. TEI Publisher from version 6.0 exposes its
        collection of Web Components targeted at creating digital editions as a separate
          <code>pb-components</code> package.</para>
      <para>You do not need to know much about <emphasis>Web Components</emphasis> to use them in
        TEI Publisher. From a user perspective, a component looks like any other HTML element. You
        configure it by setting its properties via attributes. For example, the following HTML code
        snippet will display the first page/section of two completely different documents as you can
        see below in the embedded <link xlink:show="new" xlink:href="https://codepen.io/"
          >Codepen</link> (to learn more on embedding Publisher output and components see <link
          linkend="embedding">further chapters</link>)</para>
      <programlisting language="xml" xml:space="preserve">
&lt;pb-page&gt;
  &lt;pb-document id="document1" path="test/kant_rvernunft_1781.TEI-P5.xml" odd="dta" view="page"&gt;&lt;/pb-document&gt;
  &lt;pb-document id="document2" path="doc/documentation.xml" odd="docbook" view="div"&gt;&lt;/pb-document&gt;

  &lt;!-- Display two document views side by side --&gt;
  &lt;main&gt;
      &lt;pb-view id="view1" src="document1"&gt;&lt;/pb-view&gt;
      &lt;pb-view id="view2" src="document2"&gt;&lt;/pb-view&gt;
  &lt;/main&gt;
&lt;/pb-page&gt;</programlisting>

      <programlisting role="codepen" xlink:href="wolfgangmm#WNvYYWB"/>
      <para><tag>pb-page</tag>, <tag>pb-document</tag> and <tag>pb-view</tag> are three web
        components from <code>pb-components</code> library, while <tag>main</tag> is a standard
        HTML5 tag. The name of the custom element <emphasis role="bold">must</emphasis> start with a
        prefix to distinguish it from standard HTML. This concept should be familiar to XML people.
        For TEI Publisher components, the prefix is always <code>pb-</code>. Components from other
        sources will use different prefixes, e.g. <code>paper-</code> and <code>iron-</code> for the
          <emphasis>Polymer</emphasis> collection.</para>
      <para>The part of the page which uses TEI Publisher web components should always be wrapped
        into an <tag>pb-page</tag> element. This element determines the TEI Publisher server
        instance all other components will be communicating with (see the next section below). It is
        also responsible for some other initialization steps, e.g. loading the list of available
        user interface translations. .</para>
      <para><tag>pb-document</tag> specifies a document source, which can then be referenced by id
        from other components. The component provides a way to configure basic properties governing
        document's default rendering, like associated ODD file, etc. In the example above, we define
        three properties for each document:</para>
      <variablelist>
        <varlistentry>
          <term>path</term>
          <listitem>
            <para>the relative path to the XML document. This will be interpreted as relative to the
                <emphasis>data root collection</emphasis> of TEI Publisher, by default pointing to
              the <filename>data</filename> collection within the TEI Publisher app.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry>
          <term>odd</term>
          <listitem>
            <para>the name - without suffix - of the ODD to use for rendering the document. In the
              example, the first document is encoded in TEI and thus transformed through
                <filename>dta.odd</filename>, while the second is written in DocBook and passed
              through <filename>docbook.odd</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry>
          <term>view</term>
          <listitem>
            <para>this property determines how the document will be paginated if the user navigates
              forward/backward. Currently three possible methods are available:</para>
            <orderedlist>
              <listitem>
                <para>
                  <parameter>div</parameter>: displays one structural division (TEI div, DocBook
                  section …) at a time</para>
              </listitem>
              <listitem>
                <para>
                  <parameter>page</parameter>: displays the document page by page. This requires
                  page break indicators to be present (<tag>pb</tag> in TEI, not supported for
                  docbook).</para>
              </listitem>
              <listitem>
                <para>
                  <parameter>single</parameter>: the entire document (or a selected fragment of it)
                  is displayed at once</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <tag>pb-view</tag> is the critical component in TEI Publisher: it provides the actual text
        view by transforming a part or entirety of the source XML into HTML based on the processing
        model instructions in the ODD.</para>

      <para>Because webcomponents are all about encapsulation, <tag>pb-view</tag> ensures that the
        styling of the text as governed by the ODD will be confined to the boundaries of the
        component. This makes it possible to display two completely heterogenous texts (like the
        documentation and Kant's Kritik) on the same page without styles contaminating each other.
        As a downside, encapsulation also poses some challenges, which we discussed in the section
        about <link linkend="external-css">CSS styling</link>. </para>
    </section>

    <section>
      <title>Webcomponent Documentation</title>
      <para>To better understand the various components TEI Publisher provides, it is best to have a
        look at the small examples contained in the <link xlink:show="new"
          xlink:href="../../pb-components-api/index.html">web components API documentation</link>.
        The list of components may be overwhelming at first sight. However you don’t need to learn
        them all. There are a just a few components that should be understood before you start
        customizing. Their demo pages showcase a working example along with the code snippet which
        actually implements it.</para>
      <para>You can also get an editable live view like the one above if you click on the
          <guibutton>Edit Code</guibutton> button to the bottom right of each example.</para>
      <para>In particular you may want to look at the following examples:</para>
      <variablelist>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-document/demos/demo/pb-document.html"
              >pb-document</link>
          </term>
          <listitem>
            <para>shows the example given above in action</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-view/demos/demo/pb-view.html"
              >pb-view</link>
          </term>
          <listitem>
            <para>adds navigation buttons to read the document page by page</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-facsimile/demos/demo/pb-facsimile.html"
              >pb-facsimile</link>
          </term>
          <listitem>
            <para>display facsimiles via IIIF server and link to them</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-leaflet-map/demos/demo/pb-leaflet-map.html"
              >pb-leaflet-map</link>
          </term>
          <listitem>
            <para>show a map and link to geo coordinates</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-load/demos/demo/pb-load.html"
              >pb-load</link>
          </term>
          <listitem>
            <para>call a server-side XQuery to retrieve additional information about the document,
              in this case actors appearing in the play</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-search/demos/demo/pb-search.html"
              >pb-search</link>
          </term>
          <listitem>
            <para>execute a search on the database, retrieve the results and paginate through
              them</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:show="new"
              xlink:href="../../pb-components-api/index.html#/elements/pb-grid/demos/demo/pb-grid.html"
              >pb-grid</link>
          </term>
          <listitem>
            <para>dynamically add more columns to a horizontal grid of components</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <note>
        <title>Caveat</title>
        <para>Some properties of pb-view and other components are boolean properties. In HTML5 this
          corresponds to an attribute without value, which is illegal in XML. If you want to
          preserve valid XML, just write the attribute with the same name and value, e.g.
            <code>append-footnotes="append-footnotes"</code>.</para>
      </note>
    </section>

    <section>
      <title>Communication between Components</title>
      <para>To allow for maximum flexibility, nearly all of the TEI Publisher webcomponents
        communicate via events: this way avoids hard wiring and components may appear anywhere on
        the page. For example, the controls for paginating through a document do not directly talk
        to the document view: they just send an <emphasis>event</emphasis>, indicating the users'
        wish to navigate backward or forward. Components listening for this event may then react to
        it by refreshing the text being displayed.</para>
      <para>Since you can have multiple text views showing content from different sources, every
        event can be announced at a specific communication <emphasis>channel</emphasis>. This allows
        us to distinguish between different sources, e.g. two transcriptions being shown side by
        side. Most TEI Publisher components therefore accept two properties to configure the channel
        they are listening or sending events to:</para>
      <variablelist>
        <varlistentry>
          <term>subscribe</term>
          <listitem>
            <para>name of the channel to which this component subscribes to. It will only react to
              events coming in via this channel.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>emit</term>
          <listitem>
            <para>name of the channel to which this components sends events.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>If neither of these properties is given, the component will subscribe and emit to the
        global default channel. A component may also send to a different channel than it subscribes
        to, allowing chains of events.</para>
      <para>Common properties and methods accepted by many TEI Publisher components are defined in
        the class <link xlink:show="new"
          xlink:href="../../pb-components-api/index.html#/mixins/pbMixin">PbMixin</link>.</para>
    </section>

    <section>
      <title>Page Templates</title>
      <para>TEI Publisher currently includes several different page templates, which combine the
        building blocks described above with off-the-shelf components to achieve a certain page
        layout and composition. If you look at the HTML code, you'll see a mix of
          <parameter>pb-</parameter> elements and <parameter>app-</parameter>,
          <parameter>paper-</parameter>, <parameter>iron-</parameter> elements. The last three
        belong to the <emphasis>Polymer</emphasis> collection and you can find them documented in
        the public <link xlink:href="https://www.webcomponents.org/">webcomponent registry</link>.
        TEI Publisher components are not yet available there, though we may move some of the general
        purpose components there later.</para>
      <para>To avoid redundancy, the page template files use eXist's templating feature to drag in
        some repeating parts which are the same for all pages, for example, the toolbar and the
        menu. You'll find these files in the corresponding sub-collection:</para>
      <programlisting xml:space="preserve">&lt;app-toolbar data-template="templates:include" data-template-path="templates/menu.html"/&gt;
&lt;app-toolbar data-template="templates:include" data-template-path="templates/toolbar.html"/&gt;</programlisting>
      <para>The following page templates are currently available in TEI Publisher:</para>
      <variablelist>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/view.html" role="source">view.html</link>
          </term>
          <listitem>
            <para>the default template showing a single text view at the center</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/facsimile.html" role="source">facsimile.html</link>
          </term>
          <listitem>
            <para>a template featuring a facsimile view to the right, retrieving images from a IIIF
              server</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/letter.html" role="source">letter.html</link>
          </term>
          <listitem>
            <para>used for Graves' letter, this template displays an additional map to the right and
              a list of places, people and organizations</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/translation.html" role="source"
              >translation.html</link>
          </term>
          <listitem>
            <para>shows a transcription and its translation side by side. Both are contained in the
              same TEI document and extracted via an XPath expression passed to
              <tag>pb-view</tag></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/cortez-with-translation.html" role="source"
              >cortez-with-translation.html</link>
          </term>
          <listitem>
            <para>similar to <filename>translation.html</filename> but the alignment between
              transcription and translation is more complex as the translation contains no page
              breaks. The part of the translation corresponding to a given fragment of the
              transcription thus needs to be computed dynamically for each page, using an XQuery
              function (defined by the <parameter>map</parameter> on <tag>pb-view</tag>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <link xlink:href="templates/pages/cortez" role="source">cortez.html</link>
          </term>
          <listitem>
            <para>like above but with additional facsimile panel</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><link xlink:href="templates/pages/vangogh.html" role="source"
            >vangogh.html</link></term>
          <listitem>
            <para>demonstrates three columns by default: a metadata column, a transcription which
              can be switched to a diplomatic view including line endings, and a translation. Other
              columns, e.g. facsimile or commentary can be added dynamically.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><link xlink:href="templates/pages/dantiscus.html" role="source"
              >dantiscus.html</link></term>
          <listitem>
            <para>builds upon <code>facsimile.html</code> adding a collapsible
                <code>pb-drawer</code> element to display metadata from
                <emphasis>teiHeader</emphasis> section.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><link xlink:href="templates/pages/osinski.html" role="source"
            >osinski.html</link></term>
          <listitem>
            <para>similarly builds upon <code>facsimile.html</code> but a collapsible metadata
              section is realized with a <code>pb-collapse</code> element.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <note>
        <title>Important Note</title>
        <para>The page templates are meant as examples to be copied and modified by users. They were
          written to match the concrete example and do not intend to be universal. TEI is too
          heterogenous to provide a one-size-fits-all solution. We thus believe that providing a
          wide range of practical examples is the best way to help users realize their own
          project.</para>
        <para>Only the generic template, <filename>view.html</filename> should work with all example
          TEI documents.</para>
      </note>
    </section>

    <section xml:id="customizing-page-template">
      <title>Create your own Template</title>
      <para>To create your own template</para>
      <orderedlist>
        <listitem>
          <para>open one of the existing templates in e.g. eXide (by clicking the links in the list
            above)</para>
        </listitem>
        <listitem>
          <para>adjust <code>content</code> attribute in <code>meta</code> tag to a label that fits
            your template</para>
          <programlisting language="html" xml:space="preserve">
                  &lt;meta name="description" content="XYZ edition project" /&gt;
              </programlisting>

        </listitem>
        <listitem>
          <para>save the file under a different name into the same collection
              (<filename>templates/pages</filename>)</para>
        </listitem>
      </orderedlist>

      <para>Now reload the document you'd like the template to apply to and you'll be able to switch
        to your new template, either by</para>


      <itemizedlist>
        <listitem>
          <para>using the <guibutton>Template</guibutton> dropdown in the
              <guibutton>Settings</guibutton> panel</para>
        </listitem>
        <listitem>
          <para>adding a parameter <parameter>template=mytemplate.html</parameter> to the URL showed
            by the browser</para>
        </listitem>
        <listitem>
          <para>adding a <link linkend="pi-config">processing instruction</link> to a TEI document
            to make a specific template the default:</para>
          <programlisting language="html" xml:space="preserve">&lt;?teipublisher template="translation.html" odd="dantiscus.odd" view="page"?&gt;</programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section xml:id="alignment">
      <title>Handling Complex Alignments</title>
      <para>It is often desirable to show two or more views of a document at the same time, for
        example to display the translation aligned with a given source fragment. In the simplest
        case, the transcription and translation may be aligned on the level of divisions or page
        breaks and one can simply use two <tag>pb-view</tag> referencing different starting points
        in the TEI document (this approach is implemented by the <link
          xlink:href="templates/pages/translation.html" role="source">translation.html</link>
        template for Serafin's letter).</para>
      <para>Unfortunately things are not always as simple as that. For example, even if the
        transcription contains page breaks or milestones which can be used to display a single page,
        the translation might not. One thus needs a different approach to compute the alignment
        between fragments. Nevertheless, the logic of the alignment algorithm will highly depend on
        the conventions used in the encoding. TEI allows a wide variety of alignment mechanisms and
        we do not want to limit the freedom of the editor by prescribing a particular method.</para>
      <para>TEI Publisher thus implements a generic way to plug an XQuery function into the
        processing pipeline. The function takes the source element being processed as input and may
        replace it by its aligned equivalent. Such an equivalent may be another element or fragment
        from the same or a different document. The source element will usually point to the part of
        the transcription being displayed. The mapping function uses this as starting point to
        determine an aligned fragment and returns it. The returned fragment will then be further
        passed through the processing model.</para>
      <para>The XQuery mapping function should be defined in the module
          <filename>modules/map.xql</filename>. It takes an element as its only argument and may
        return any valid TEI fragment, which will become the input for futher processing through the
        processing model.</para>
      <para>The local name of the mapping function can then be supplied in the attribute
          <parameter>map</parameter> of <tag>pb-view</tag>. As an illustration, the Van Gogh example
        includes the following <code>pb-view</code> for displaying the translation:</para>
      <programlisting language="xquery" xml:space="preserve">&lt;pb-view src="document1" map="vg-translation" xpath="//div[@type='original']"
    subscribe="transcription"/></programlisting>
      <para>In the Van Gogh letters, the translation contains page breaks corresponding to page
        breaks in the original letter, but these are using a different prefix for the
          <code>xml:id</code>. To align the translation with the transcription, we only need to
        adjust the id, and retrieve the corresponding page break to be done. The XQuery mapping
        function is thus rather simple:</para>
      <programlisting language="xquery" xml:space="preserve">declare function mapping:vg-translation($root as element()) {
    let $id := ``[pb-trans-`{$root/@f}`-`{$root/@n}`]``
    let $node := root($root)/id($id)
    return
        $node
};</programlisting>
      <para>Note that returning the corresponding <tag>pb</tag> node of the translation is
        sufficient here as further processing will automatically extract the page fragment up to the
        next <tag>pb</tag>. More complex cases may require that mapping function returns arbitrary
        TEI fragment. Also note that the <parameter>xpath</parameter> attribute of the
          <tag>pb-view</tag> element in the template must still point to the source transcription
          (<parameter>div[@type='original']</parameter> in this case). It's just the mapping
        function which translates a position in the source transcription to a corresponding fragment
        in the translation.</para>
      <para>The letter by Cortez to Dantiscus sent from Mexico demonstrates a much more
        sophisticated alignment, determining the translation fragment to be shown by inspecting the
        ID range of the transcription. It illustrates the case where no milestone elements exist in
        the translation to explicitly mark page boundaries of the original, thus mapping algorithm
        aims to display closest corresponding fragment of the translated text.</para>
    </section>
  </section>

  <section xml:id="i18n">
    <title>Language versions</title>
    <para>TEI Publisher is available in more than a dozen languages and this number increases thanks
      to the engagement of our user community.</para>

    <para>In version 6.0 i18n support has been greatly extended to cover not only labels and
      attribute values in HTML templates but also within web components. A mechanism for project
      specific language files extending the default Publisher label collection has been
      added.</para>
    <para>Thanks to community contributions via <link xlink:href="https://crwd.in/tei-publisher"
        >Crowdin</link> a number of new languages has been added and existing ones updated. We
      welcome and encourage additions and amendments. Please consider Crowdin a master repository
      for translations and publish your contributions there instead of submitting PR directly. Do
      not hesitate to get in touch if a language you'd like to support is not yet listed.</para>
    <para>Crowdin users are only exposed to form-based graphical user interface but i18n files are
      using JSON format to preserve their logical structure. Initial portion of German localization
      file <filename>de.json</filename> is shown below for illustration.</para>
    <figure>
      <title>Translation JSON file structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="i18n-json-structure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>In TEI Publisher and in generated apps translation files are by default loaded from CDN
      with <code>pb-components</code>. When it is necessary for a project to add new labels or
      change wording of existing ones, a customization mechanism is described <link
        linkend="i18n-customization">below</link>.</para>
    <section>
      <title>Using i18n in page templates</title>
      <para>There are several scenarios for using i18n labels:</para>
      <itemizedlist>
        <listitem>
          <para>directly within HTML element</para>
        </listitem>
        <listitem>
          <para>in an attribute</para>
        </listitem>
        <listitem>
          <para>passed in component-specific structure</para>
        </listitem>
      </itemizedlist>
      <section>
        <title>HTML text node with <code>pb-i18n</code></title>
        <para>Any text fragment within HTML element can be considered a target for i18n when wrapped
          in <tag>pb-i18n</tag> component. <tag>pb-i18n</tag> elements are listening for events
          emitted by <tag>pb-lang</tag>.</para>
        <programlisting language="html" xml:space="preserve">
&lt;h3 slot="collapse-trigger">
   &lt;pb-i18n key="menu.documentation">Documentation&lt;/pb-i18n>
&lt;/h3>
        </programlisting>
      </section>
      <section>
        <title>Attributes (on HTML elements or custom web components)</title>
        <para>When it is necessary to translate the value of an attribute a mechanism based on
            <code>data-</code> attributes is used. Supply additional <code>data-i18n</code>
          attribute specifying the key of the i18n label to use preceded by the name of the
          attribute that needs to be translated. In the example below it's the <code>heading</code>
          attribute that needs to be filled with the translated version of <emphasis>ODD
            Files</emphasis> label. The label is stored in JSON file under <code>odd.files</code>,
          so <code>[heading]odd.files</code> needs to be used for the <code>data-i18n</code>
          attribute.</para>
        <programlisting language="xml" xml:space="preserve">
&lt;paper-card data-i18n="[heading]odd.files" class="odds" heading="ODD Files">
   &lt;div class="card-content"> ... content of the ODD list &lt;/div>
&lt;/paper-card>
        </programlisting>
        <para>When <tag>pb-lang</tag> is switched to Spanish, the <tag>paper-card</tag> heading will
          read <emphasis>Archivos ODD</emphasis> instead of <emphasis>ODD Files</emphasis>.</para>
        <figure>
          <title>Output for <tag>paper-card</tag> with translated <code>@heading</code></title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="i18n-attribute.png" width="300px"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>Special web component properties configured via attributes</title>
        <para>Some web components accept more complex configuration options via arrays passed in
          attributes. For example, <tag>pb-browse-docs</tag> component allows to specify a number of
          label/value pairs for dropdown menus used for ordering and filtering the document list.
          Understandably, the labels should switch in line with changes to the language chosen via
            <tag>pb-lang</tag>. Therefore i18n translation keys like
            <emphasis>browse.title</emphasis> or <emphasis>browse.author</emphasis> are used instead
          of text values. Note that web components may have particular expectations for the data
          format expected so consult API documentation for each component.</para>
        <programlisting language="html" xml:space="preserve">
&lt;pb-browse-docs id="document-list" url="collection/" 
      sort-options='[{"label": "browse.title", "value": "title"},{"label": "browse.author", "value": "author"}]' 
      sort-by="title"
      filter-options='[{"label": "browse.title", "value": "title"},{"label": "browse.author", "value": "author"},{"label": "browse.file", "value": "file"}]' 
      filter-by="title" 
      auto="auto" history="history" login="login" emit="docs" subscribe="docs">
  &lt;pb-paginate slot="toolbar" id="paginate" per-page="10" range="5" emit="docs" subscribe="docs">&lt;/pb-paginate>
&lt;/pb-browse-docs>
         </programlisting>
      </section>
    </section>

    <section xml:id="i18n-customization">
      <title>Project specific i18n files</title>
      <para>It is a common need that projects will need their own internationalized labels for menu
        items, dialogs and other user interface elements.</para>
      <para>All these can be stored in JSON language files, following the same naming conventions
        and basic structure as TEI Publisher ones. Custom application files should be placed in
          <filename>app</filename> subcollection of <filename>resources/i18n</filename>
        collection.</para>
      <para>For page template to use custom language files a <code>locale</code> attribute needs to
        be explicitly set to <code>resources/i18n</code> for <tag>pb-page</tag>.</para>
      <para>All labels defined in custom files will be available in addition to TEI Publisher's
        defaults. If custom file defines translation for a key already present in TEI Publisher, the
        value from the custom file will take precedence.</para>
      <programlisting language="html" xml:space="preserve">
&lt;pb-page locales="resources/i18n">
        </programlisting>
      <para>Please note to always use a subcollection for custom files, namely
          <filename>resources/i18n/app</filename>. Placing custom language files directly in
          <filename>resources/i18n</filename> will prevent fallback-to-defaults mechanism for labels
        not present in custom language files.</para>
      <para>Listing below demonstrates a fictional <filename>en.js</filename> with a custom set of
        labels.</para>
      <para>New top-level key has been added as well as 3 subkeys for <code>menu</code> section. Now
        the project has access to a number of new i18n keys: <code>menu.about</code>,
          <code>menu.contact</code>, <code>menu.statute</code> and <code>greeting</code>.</para>
      <para>Furthermore, value for <code>menu.documentation</code> has been specified. That key
        already existed in Publisher (set to "Documentation") but version from custom file will take
        precedence and be used in the custom app.</para>
      <programlisting language="js" xml:space="preserve">
{
  "menu": {
    "documentation": "Docu",
    "about": "About",
    "contact": "Contact",
    "statute": "Statute"
    },
  "greeting": "Welcome"
}
      </programlisting>
      <para/>
    </section>
  </section>
  <section xml:id="pi-config">
    <title>Processing instructions</title>
    <para>The default view for a specific document can be configured via a processing instruction.
      Before displaying a document, TEI publisher will check if a processing instruction exists at
      the start of the document, telling it which ODD and view template to use (along with other
      configuration parameters). For example, the following processing instruction associates the
      document with the view template <filename>translation.html</filename>, the ODD
        <filename>dantiscus.odd</filename>, and switches to a page-by-page display (along TEI page
      break boundaries):</para>
    <programlisting language="xml" xml:space="preserve">&lt;?teipublisher template="translation.html" odd="dantiscus.odd" view="page"?&gt;</programlisting>
    <para>When viewing the document by structural divisions, two additional settings control the
      amount of content displayed at a time:</para>
    <programlisting language="xml" xml:space="preserve">&lt;?teipublisher depth="2" fill="6" odd="dta.odd"?&gt;</programlisting>
    <variablelist>
      <varlistentry>
        <term>odd</term>
        <listitem>
          <para>The ODD file to use for rendering the document.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>template</term>
        <listitem>
          <para>The HTML view template to use. Default is <code>view.html</code> as configured in
              <filename>modules/config.xqm</filename>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>view</term>
        <listitem>
          <para>Default view to show when browsing the document. Supported values are
              <parameter>div</parameter>, <parameter>page</parameter> or
              <parameter>single</parameter>:</para>
          <orderedlist>
            <listitem>
              <para>
                <parameter>div</parameter>: displays one structural division (TEI div, docbook
                section …) at a time</para>
            </listitem>
            <listitem>
              <para>
                <parameter>page</parameter>: displays the document page by page. This requires page
                break indicators to be present (<tag>pb</tag> in TEI, not supported for
                docbook).</para>
            </listitem>
            <listitem>
              <para>
                <parameter>single</parameter>: the entire document (or a selected fragment of it) is
                displayed at once</para>
            </listitem>
          </orderedlist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>depth</term>
        <listitem>
          <para>When viewing entire divisions, the software tries to determine if it should show
            child divisions in separate pages or include them with the current div. <tag>depth</tag>
            indicates the nesting level up to which divisions should be shown separately. So setting
            it to "2" will result in divisions on level 3 or greater to be shown together with their
            enclosing div.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>fill</term>
        <listitem>
          <para>If child divisions appear on separate pages, it may happen that the enclosing div
            contains just a heading or a single line of text. In this case, the algorithm will try
            to fill the page by showing the first child division as well. The <tag>fill</tag>
            paramter defines the number of elements which should at least be present on a page. If
            not, the software tries to fill it up.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section xml:id="facets">
    <title>Facet Search Configuration</title>
    <para>Facets allow users to quickly navigate through a set of documents or query results by
      selecting from predefined categories or properties. This way, users can "drill down" into the
      set, reducing the number of displayed items with every step. For demonstration purposes, TEI
      Publisher configures two facets by default: "Genre" and "Language". You can see those to the
      left of the document list on the start page, or below the search box on the search result
      page.</para>
    <figure>
      <title>Facets on the start page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="facets.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>From a user perspective, the main concept behind facets is the <emphasis>drill
        down</emphasis>: initially the user sees all facet values associated with the set of
      documents or search results displayed. The number behind each value denotes the number of
      items in the set having the particular facet set. As the user selects one facet, the set
      necessarily becomes smaller, so non-matching facet values will disappear and the numbers
      adjust accordingly.</para>
    <para>Facets are a new feature in eXist 5.0. They are super fast because eXist will create them
      when indexing the document. No extra computation is needed when the user clicks on a facet to
      drill down into a displayed set: all information is already available in the index. To see a
      more complex example of facets in action, visit our <link xlink:show="new"
        xlink:href="https://teipublisher.com/exist/apps/vangogh/index.html">Van Gogh</link>
      demo.</para>
    <para>If you would like to configure other or additional facets, you need to edit three
      files:</para>
    <variablelist>
      <varlistentry>
        <term><filename>collection.xconf</filename></term>
        <listitem>
          <para>The <filename>collection.xconf</filename> tells eXist how to index the collection.
            The default configuration in TEI Publisher creates two Lucene full-text indexes for TEI
            on <tag>tei:text</tag> and <tag>tei:div</tag>. Each of those may have facets attached.
            Every facet must have a <parameter>dimension</parameter> and an
              <parameter>expression</parameter> attribute. The expression is an arbitrary
            XPath/XQuery string. For every element being indexed, the expression is evaluated once
            and the result defines the string values which will be associated with the specified
            facet dimension.</para>
          <para>For a description of how full-text indexes and facets are defined in the
              <filename>collection.xconf</filename>, please refer to the <link xlink:show="new"
              xlink:href="http://exist-db.org/exist/apps/doc/lucene">eXist
            documentation</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><filename>index.xql</filename></term>
        <listitem>
          <para>If you open the default <filename>collection.xconf</filename>, you'll see that most
            facet expressions call a function <function>nav:get-metadata</function>. This function
            is declared in <filename>index.xql</filename>. By externalizing most of the code into a
            separate function, we can keep the index configuration clean and short.</para>
          <para>The default <filename>index.xql</filename> already does some advanced preprocessing,
            in particular for the "genre" facet: each of the sample documents references a central
            taxonomy (contained in <filename>data/taxonomy.xml</filename>). The references are
            resolved at indexing time by following the <tag>catRef</tag> element's
              <parameter>@target</parameter> attribute. Note that we create a hierarchical facet,
            because e.g. "Philosophy" is a sub-category of "Prose". The code in function
              <function>idx:get-genre</function> will automatically include the
            super-category.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><filename>config.xqm</filename></term>
        <listitem>
          <para>While the other two files cover the server-side creation of facets, we also need a
            place where we define how facets should be displayed in the user interface. The main
            configuration module: <filename>config.xqm</filename> declares a variable
              <parameter>$config:facets</parameter>. It should contain an array of maps, where each
            map defines the settings for one dimension, e.g.:</para>
          <programlisting language="xquery" xml:space="preserve">
(:
 : Display configuration for facets to be shown in the sidebar. The facets themselves
 : are configured in the index configuration, collection.xconf.
 :)
declare variable $config:facets := [
    map {
        "dimension": "genre",
        "heading": "Genre",
        "max": 5,
        "hierarchical": true()
    },
    map {
        "dimension": "language",
        "heading": "Language",
        "max": 5,
        "hierarchical": false(),
        "output": function($label) {
            switch($label)
                case "de" return "German"
                case "es" return "Spanish"
                case "la" return "Latin"
                case "fr" return "French"
                case "en" return "English"
                default return $label
        }
    }
];
</programlisting>
          <para>The map properties are as follows:</para>
          <variablelist>
            <varlistentry>
              <term>dimension</term>
              <listitem>
                <para>The name of the dimension. Should correspond to the value of the
                    <parameter>@dimension</parameter> attribute used in
                    <filename>collection.xconf</filename></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>heading</term>
              <listitem>
                <para>The heading to display above the facet values</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>max</term>
              <listitem>
                <para>Maximum number of facet values to be displayed initially. More can be shown if
                  the user clicks on the <guilabel>Show All</guilabel> checkbox. Pass an empty
                  sequence, i.e. (), to not limit the number and hide the checkbox.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>hierarchical</term>
              <listitem>
                <para>Defines if the facet is hierarchical, which means that only the top-level
                  facet values in the hierarchy will be shown initially. If the user selects one
                  top-level value, the interface will expand and show the sub-categories. For this
                  to work the facet must be configured as "hierarchical" in
                    <filename>collection.xconf</filename></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>output</term>
              <listitem>
                <para>A function which can be used to process the facet value before display. The
                  facet label will be replaced by whatever the function returns.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>


  <section xml:id="appgen">
    <title>Creating applications with the App Generator</title>
    <para>Once you are happy with a certain ODD and HTML template customization, you can easily
      create a complete, standalone application. Such application can be tailored further to fit
      your needs. The generated app can be downloaded as a portable xar package, to be installed
      into other eXist instances, or synchronised to disk for further development. It provides a
      fully functional application scaffolding based on TEI Publisher components and modules,
      pre-configured to use a certain ODD, page template and other settings.</para>
    <note>
      <title>Note</title>
      <para>Previous versions of the TEI Publisher included everything they needed to run without
        TEI Publisher. This had some advantages, but also made it more difficult to update to newer
        releases.</para>
      <para>Starting with version 5 we are gradually moving towards more lightweight app design,
        ultimately containing only resources which are truly specific to the app (ODDs, HTML
        templates, images), while all generic functionality will be provided by TEI Publisher and
        its libraries and packages. Version 6 has seen all web components extracted into
          <code>pb-components</code> package and planned version 7 aims to redesign and factor out
        many parts of navigation and search modules.
        <!--TEI Publisher itself will get an app administration page, which will allow users to
          manage and customize all installed apps from a central management shell.--></para>
      <para>Until then, please make sure you are following our <link
          linkend="customization-best-practice">best practice recommendations</link> for a smooth
        upgrade path.</para>
    </note>
    <para>To get started, click on <guimenuitem>App Generator</guimenuitem> in the menu bar and fill
      out the form.</para>

    <para>The following form fields are of particular importance:</para>
    <variablelist>
      <varlistentry>
        <term>ODD</term>
        <listitem>
          <para>Name of the ODD (discussed above) to be used for transformations.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>URL to identify the app</term>
        <listitem>
          <para>This is the main identifier for your app and should be a globally unique URI. It
            does not need to correspond to any existing web site. eXist's package manager is using
            this URI as a unique identifier for the app.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Abbreviation</term>
        <listitem>
          <para>The abbreviation will be used as the name of the root collection of your app and as
            the last path component in any URL pointing to the app. It should be unique within one
            database instance.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Template</term>
        <listitem>
          <para>The HTML template to be used as default for viewing a document. If you created a
            custom template or modified any of the existing templates, you likely want to select
            this here.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data Collection</term>
        <listitem>
          <para>Only specify something here if you have existing data inside the database or if you
            want to ship the data set as part of a second, separate app. In all other cases, leave
            this field empty.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Default View</term>
        <listitem>
          <para>Default document view - whole document, page by page or division by division. If you
            would like to choose page by page, set this to <guimenuitem>"By Page"</guimenuitem> but
            please note that all your documents must be appropriately encoded with page breaks as
              <tag>pb</tag> elements. You will still be able to change the view settings in HTML
            template or users can do it via query parameters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>User/Password</term>
        <listitem>
          <para>The user account which will own all application files. For security reasons, it is
            advisable to create a new account for every app.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>Once you created the new application, log into it using the account details you provided.
      You can then upload XML documents using the upload panel in the sidebar.</para>
    <figure xml:id="create-app">
      <title>Create an App</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="CreateApp.gif"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Generated Code Overview</title>
      <section>
        <title>XQuery Code</title>
        <para>The collection structure of the generated app follows typical design of many eXist
          apps. <link linkend="customization-best-practice">Best practices</link> for modifying the
          app are discussed in further sections of this document. You can find the code of your
          generated app in within the <filename>/db/apps</filename> collection under the name you
          provided in the <emphasis>abbreviation</emphasis> field of the generator form.</para>
        <variablelist>
          <varlistentry>
            <term>modules</term>
            <listitem>
              <para>Contains XQuery modules used by the app, including the copied TEI Publisher
                libraries in <filename>modules/lib</filename> subcollection. </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>resources</term>
            <listitem>
              <para>Contains a number of subcollections for various resources used by the app, such
                as images, fonts or JavaScript libraries. Of particular interest is the
                  <filename>resources/odd</filename> subcollection where app's own ODD files are
                stored.</para>
              <para>All of the app styling is done via a set of modularized less stylesheets,
                residing in <filename>resources/css</filename>. The main file is
                  <filename>style.less</filename>, which defines a number of core parameters.
                Ideally this should be the only file you ever need to modify.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>templates</term>
            <listitem>
              <para>Html templates for the templating framework. Contain page templates as well as
                smaller components such as menu or login pane.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>transform</term>
            <listitem>
              <para>This collections contains XQuery modules governing the transformations and
                styles generated from app's ODD. Its content will be overwritten with each ODD
                recompilation, thus there's no point modifying it. It's worth consulting though to
                gain better understanding and troubleshoot the transformations with TEI Processing
                Model. In case of an issue, it may help to know the files: </para>
              <variablelist>
                <varlistentry>
                  <term>{myodd}-web.xql</term>
                  <listitem>
                    <para>The transformation module generated for output mode "web".</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>{myodd}-web-module.xql</term>
                  <listitem>
                    <para>Library module which calls the transformation module.</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>{myodd}.css</term>
                  <listitem>
                    <para>CSS styles generated from the ODD.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
              <para>Files start with the name of the odd and the output mode they belong to.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section>
      <title>Modifying the App</title>
      <para>When you are logged in, the "Admin" menu in the top navbar provides various links for
        ease of customization of your app:</para>
      <variablelist>
        <varlistentry>
          <term>Recompile ODD</term>
          <listitem>
            <para>After changing the application's ODD, click here to update the app.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Edit ODD</term>
          <listitem>
            <para>Opens the application's ODD in eXide for editing.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Exporting the Finished App</title>
      <para>To save your finished application or exchange it with other people, you need to save it
        as an application archive. Application archives use a standardized <link xlink:show="new"
          xlink:href="https://exist-db.org/exist/apps/doc/repo#expath-pkg">EXPath Packaging</link>
        format: the resulting <filename>.xar</filename> file can be uploaded to any eXist instance
        via the <guibutton>Dashboard</guibutton> and the <guibutton>Package manager</guibutton> will
        take care of the deployment.</para>
      <para>There are three ways to create a <filename>.xar</filename> file from your
        application:</para>
      <itemizedlist>
        <listitem>
          <para>Use the <guibutton>Admin </guibutton> / <guibutton>Download App</guibutton> menu
            entry in generated app to directly download a <filename>.xar</filename></para>
        </listitem>
        <listitem>
          <para>Use the <guibutton>Application</guibutton> / <guibutton>Download App</guibutton>
            menu entry in <emphasis role="bold">eXide</emphasis> to directly download a
              <filename>.xar</filename></para>
        </listitem>
        <listitem>
          <para>Synchronize the application to a directory on disk via
              <guibutton>Application</guibutton> / <guibutton>Synchronize</guibutton> in <emphasis
              role="bold">eXide</emphasis> and build <code>xar</code> with <code>ant</code></para>
        </listitem>
      </itemizedlist>
      <para>The last approach is the recommended one. It requires that you have access to the file
        system of the server running eXist though, so it's usually only an option if you run your
        own eXist instance locally. The synchronize steps in detail:</para>
      <itemizedlist>
        <listitem>
          <para>Prerequisite: you need to have the <link xlink:show="new"
              xlink:href="http://ant.apache.org/">Apache Ant</link> build tool installed.</para>
        </listitem>
        <listitem>
          <para>Open one resource belonging to your application in eXide. It doesn't matter which
            one. The only important thing is that the name of your app is displayed next to
              <guibutton>Current app:</guibutton> on the top right of the eXide window. If this is
            not the case, stop and check again!</para>
        </listitem>
        <listitem>
          <para>Click <guibutton>Application</guibutton> / <guibutton>Synchronize</guibutton> in the
            menu. It opens up a dialog with two fields: <guibutton>Start time</guibutton> and
              <guibutton>Target directory</guibutton>. When you synchronize the first time, empty
            the <guibutton>Start time</guibutton> field. Enter a valid, absolute directory path on
            your server machine into <guibutton>Target directory</guibutton>.</para>
        </listitem>
        <listitem>
          <para>Click the <guibutton>Synchronize</guibutton> button. This may take a moment, but you
            should see a list of written files at the bottom of the dialog afterwards.</para>
        </listitem>
        <listitem>
          <para>Change to the directory you specified for synchronize.</para>
        </listitem>
        <listitem>
          <para>Calling <code>ant</code> inside the directory should create a fresh
              <code>.xar</code> file in the build/ subdirectory.</para>
        </listitem>
      </itemizedlist>

      <para>Watch the screencast below for the whole synchronization procedure.</para>
      <note>
        <title>Note</title>
        <para>for security reasons, the password you entered when creating the app is not stored in
          the database, so it cannot be synchronized to disk. To restore a password for your app,
          you thus need to edit the <filename>repo.xml</filename> file in the directory and add a
            <parameter>@password</parameter> attribute to the <tag>permissions</tag> element.</para>
      </note>
      <figure xml:id="sync">
        <title>Export an App</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Sync.gif"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
  <section xml:id="customization-best-practice">
    <title>Best Practice Recommendations</title>
    <para>In case you'd wish to further customize the generated app it's worth to keep the changes
      as much separated from the generated code as possible to allow for future alignment with newer
      versions of the TEI Publisher. </para>
    <para>The generated app shares most of its XQuery libraries with the main TEI Publisher app. A
      copy of those is included in the <filename>lib/</filename> collection of the generated app and
        <emphasis role="bold">should not</emphasis> be modified! This way you can later update the
      libraries to a newer TEI Publisher release without breaking your app. Including the libraries
      in the generated app creates some redundancy, but we chose to accept this trade-off to make it
      easier to view and modify everything relevant to the app. Be advised that, as explained
      earlier in this chapter, we are moving towards more lightweight app design and many of the
      function modules may be moved into separate libraries in the future.</para>
    <para>Meanwhile, if you find that modifications of <filename>lib/</filename> modules are
      necessary, please consider if your change would be generally beneficial for TEI Publisher and
      create PR for the TEI Publisher if so.</para>
    <para>It is considered safe:</para>
    <orderedlist>
      <listitem>
        <para>to modify all HTML templates below <filename>templates/</filename> as well as
            <filename>index.html</filename> and <filename>search.html</filename> in the root of the
          app</para>
      </listitem>
      <listitem>
        <para>to change XQuery modules in <filename>modules</filename>, excluding those in
            <filename>modules/lib</filename></para>
      </listitem>
      <listitem>
        <para>to add images, fonts or change i18n translations below
          <filename>resources</filename></para>
      </listitem>
      <listitem>
        <para>add new XQuery modules into <filename>modules</filename>, which may be called from
          e.g. web components.</para>
      </listitem>
    </orderedlist>
    <para>The following core XQuery modules in every app are safe to be modified (all are stored in
        <filename>modules</filename> subcollection:</para>
    <variablelist>
      <varlistentry>
        <term><filename>config.xqm</filename></term>
        <listitem>
          <para>The main configuration file for the app. It contains a number of parameters which
            control important aspects.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><filename>app.xql</filename></term>
        <listitem>
          <para>Add your own HTML templating functions in XQuery here if needed. With TEI Publisher
            4.0 or later, there should be less of a need to extend this file as most of the
            application logic is realized via web components.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><filename>pm-config.xql</filename></term>
        <listitem>
          <para>This file defines the functions to be called for rendering TEI content via the
            processing model. It imports the modules generated from your ODD and assigns them to
            variables as function pointers. This approach is much more efficient than the dynamic
            lookups done by the main TEI Publisher app. It has been production tested on large web
            sites. The downside is that the connection to the ODD is hard-coded. If you need to
            switch between different ODDs, you would need to change<filename>
              pm-config.xql</filename> and insert a proper switch there depending on external
            parameters.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>navigation-*.xql</term>
        <listitem>
          <para>This group of modules contains functions relevant for the display and navigation of
            documents corresponding to a given document type</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>*-query.xql</term>
        <listitem>
          <para>Modules with functions powering the search features</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>view.xql</term>
        <listitem>
          <para>The main module of the app. This module initializes eXist's templating system. The
            only case when it should be modified is if you want to add further XQuery library
            modules containing template functions.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="updating">
    <title>Updating Applications</title>

    <para>Updating an app generated with TEI Publisher 4.x.x/5.x.x still requires some manual steps,
      though we're working towards reducing the dependencies. Future updates should become easier.
      There are two possible approaches for updating:</para>
    <itemizedlist>
      <listitem>
        <para>generate a new application with TEI Publisher 6 and copy the files you changed in your
          app into the newly generated app. This is recommended if the customizations you did apply
          were limited to e.g. ODD files, CSS styles, templates, index configurations or a few of
          the files in <filename>modules/</filename>.</para>
      </listitem>
      <listitem>
        <para>update your generated app by modifying the HTML templates you use and copying files
          from TEI Publisher.</para>
      </listitem>
    </itemizedlist>
    <para>The first option is much easier in general. We only recommend to go with the second option
      if you app is heavily customized and - in particular - contains many changes to the XQuery
      files.</para>

    <section>
      <title>Update by Generating a New Application</title>
      <procedure>
        <step>
          <para>Upload your customized ODD to TEI Publisher</para>
        </step>
        <step>
          <para>If you created a custom HTML template for your document view, upload it to the
              <filename>templates/pages</filename> collection of TEI Publisher. You can use eXide's
            file manager to do so.</para>
        </step>
        <step>
          <para>Generate a new application using your custom ODD. Make sure you select a different
            URL and short name to not confuse the two apps.</para>
        </step>
        <step>
          <para>Selectively upload all remaining files you changed or resources you added to the
            generated app</para>
        </step>
      </procedure>
    </section>

    <section>
      <title>Update by Copying</title>
      <para>The following steps assume that you either</para>
      <itemizedlist>
        <listitem>
          <para>have a copy of your app's code on the filesystem and a clone of TEI Publisher 6 next
            to it</para>
        </listitem>
        <listitem>
          <para>or have your app and TEI Publisher installed in your database. In this case use
            eXide's file manager to copy files</para>
        </listitem>
      </itemizedlist>
      <procedure>
        <step>
          <para>Edit <filename>modules/config.xqm</filename> and add two variables at the top:
              <code>$config:origin-whitelist</code> and <code>$config:webcomponents</code>.</para>
          <para><parameter>$config:webcomponents</parameter> should point to the latest version of
            pb-components.</para>
          <programlisting language="xquery" xml:space="preserve"><![CDATA[
(:~
 : A list of regular expressions to check which external hosts are
 : allowed to access this TEI Publisher instance. The check is done
 : against the Origin header sent by the browser.
 :)
declare variable $config:origin-whitelist := (
"(?:https?://localhost:.*|https?://127.0.0.1:.*)"
);

(:~~
 : The version of the pb-components webcomponents library to be used by this app.
 : Should either point to a version published on npm,
 : or be set to 'local'. In the latter case, webcomponents
 : are assumed to be self-hosted in the app (which means you
 : have to npm install it yourself using the existing package.json).
 : If a version is given, the components will be loaded from a public CDN.
 : This is recommended unless you develop your own components.
 :)
declare variable $config:webcomponents := "0.9.11";]]></programlisting>

        </step>
        <step>
          <para>Copy all XQuery files from <filename>tei-publisher-app/modules/lib</filename> into
            the <filename>modules/lib</filename> of your application. </para>
        </step>
        <step>
          <para>Copy <filename>tei-publisher-app/resources/css/theme.css</filename> into the same
            location in your application.</para>
        </step>
        <step>
          <para>In all HTML files <emphasis>you changed for your app</emphasis>, check
              <tag>head</tag> and remove any <tag>script</tag> element or <tag>link</tag> doing an
            import like:</para>
          <programlisting language="html"><![CDATA[<link rel="import" href="components/dependencies-dev.html"/>]]></programlisting>
          <para>Instead add the following line to the head:</para>
          <programlisting language="html"><![CDATA[<script type="module" src="pb-components-bundle.js" data-template="pages:load-components"></script>]]></programlisting>
          <para>Also add a link to <filename>theme.css</filename>:</para>
          <programlisting language="html"><![CDATA[<link rel="stylesheet" href="resources/css/theme.css"/>]]></programlisting>
        </step>
        <step>
          <para>HTML files you did not change may just be overwritten by copying the corresponding
            versions from <code>tei-publisher-app</code>. In particular this includes files in the
              <filename>tei-publisher-app/templates/basic/templates</filename> subdirectory or
              <filename>tei-publisher-app/templates/basic/search.html</filename>.</para>
        </step>
        <step>
          <para>Copy <filename>tei-publisher-app/templates/basic/controller.xql</filename> into the
            root of your application - unless you made changes to this file yourself, in which case
            you would need to merge it.</para>
        </step>
        <step>
          <para>Check the files in modules within your app: if you have not changed any of them,
            just copy the corresponding files from <filename>tei-publisher-app/modules</filename>.
            See if you need to merge the modified ones.</para>
        </step>
      </procedure>
    </section>
  </section>

  <section>
    <title>Creating Custom Web Components</title>
    <para>In some cases an app may need to add its own web components to the collection provided by
      TEI Publisher. Please consider following <emphasis role="bold">open-source-first
        approach</emphasis>, as we do, and contributing your component back to the community, for
      others to use.</para>
    <para>For that reason, we recommend here a setup which leads to relatively smooth integration
      with <code>pb-components</code> in the future.</para>
    <para>Start with forking and downloading the <code>pb-extension-template</code> package from its
        <link xlink:show="new" xlink:href="http://github.com/eeditiones/pb-extension-template"
        >GitHub repository</link>.</para>
    <figure>
      <title>Visual Studio Code overview of pb-extension-template</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="component-extension.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>You will find it already includes several configuration files to get you started on the
      development.</para>
    <itemizedlist>
      <listitem>
        <para><filename>package.json</filename> file which includes definition and specifications
          for common task, like generating documentation or running a web server for local
          development</para>
      </listitem>
      <listitem>
        <para><filename>src</filename> directory to put your custom web component code. It already
          includes <filename>pb-clipboard.js</filename> file as an example of a simple
          component</para>
      </listitem>
      <listitem>
        <para><filename>index.html</filename> file which illustrates the simplest scaffolding for
          using your new components</para>
      </listitem>
      <listitem>
        <para><filename>demo</filename> directory to place your demo files for testing and
          documentation purposes. It already contains <filename>demo.js</filename> configuration
          file and <filename>pb-clipboard.html</filename> demo for <tag>pb-clipboard</tag>.</para>
      </listitem>
      <listitem>
        <para><filename>api.html</filename> file serving as a documentation starting point for your
          package</para>
      </listitem>
      <listitem>
        <para><filename>rollup.config.js</filename> provides building specification to create a
          bundle that can be included in any web page.</para>
      </listitem>
    </itemizedlist>
    <para>To get you started, run <code>npm install</code>. This will install required dependencies:
      above all <code>pb-components</code> but also <code>es-dev-server</code> and
        <code>web-component-analyzer</code> packages which are needed for local development and
      documentation.</para>
    <figure>
      <title>Visual Studio Code snippet</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="litelem-vscode-snippet.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>If you are using Visual Studio code <filename>.vscode/component.code-snippets</filename>
      will provide you with code templates. If you create a new file in <filename>src</filename>,
      e.g. <filename>pb-foo.js</filename> and start typing <emphasis>litelement</emphasis> you will
      be offered a LitElement template. Otherwise you can copy the template manually or copy
      existing <tag>pb-clipboard</tag> element and tweak it.</para>
    <figure>
      <title>LitElement template</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="litelem-template.png" width="600px"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>pb-clipboard example</title>
      <para>We will discuss the details of the <tag>pb-clipboard</tag> element to illustrate some
        basic concepts. You will find exact code of this example in
          <code>pb-extension-template/src/pb-clipboard.js</code>. Each custom component has a
        defined API: an interface it presents to the outside world. It includes properties, methods
        (also called functions) and events but it bundles HTML markup along with local CSS and
        JavaScript into a single file.</para>
      <para>Our example is a custom element designed to provide simple
          <emphasis>copy-to-clipboard</emphasis> functionality, helpful e.g. when providing
        ready-made citation on a page. It consists of three parts: a label, the content to be copied
        and a button to copy.</para>
      <para>Thus, render function which actually displays this custom component could look like
        this:</para>
      <programlisting language="js" xml:space="preserve">
    render() {
        return html`
            &lt;h3>${translate(this.label)}&lt;/h3>
            &lt;div>
                &lt;slot>&lt;/slot>
                &lt;paper-icon-button icon="icons:content-copy" @click="${this._copy}"
                    title="${translate('clipboard.copy')}">&lt;/paper-icon-button>
            &lt;/div>
        `;
    }
      </programlisting>
      <para>You will note that the render function uses not only regular HTML elements like
          <tag>h3</tag> or <tag>div</tag> but also components from the <code>paper-</code> package.
        To be able to use them, we need to explicitly import them. Same is true for
          <code>LitElement</code> class itself and important interface from the
          <code>pb-components</code> package: <code>pbMixin</code>.</para>
      <para>All user interface components may need to be localized. For that reason we also import
          <code>translate</code> method from TEI Publisher's <code>i18n</code> module.</para>
      <para><code>LitElement</code> and <code>pbMixin</code> must be imported for all custom
        components extending <code>pb-components</code>. Code listing below demonstrates how to
        correctly import all classes and custom elements required as well as how to create a class
        signature that extends <code>pbMixin</code>.</para>
      <programlisting language="js" xml:space="preserve">
import { LitElement, html, css } from 'lit-element';
import { pbMixin } from '@teipublisher/pb-components/src/pb-mixin';
import { translate } from "@teipublisher/pb-components/src/pb-i18n";
import '@polymer/paper-icon-button';
import '@polymer/iron-icons';

/**
 * A component with a button which copies the contained content to the clipboard.
 * Use for the typical 'quote this content as' hints on a webpage.
 * 
 * @slot content - contains the actual content to copy to the clipboard
 */
export class PbClipboard extends pbMixin(LitElement) {
      </programlisting>

      <para>Imports and render function sorted, there are two other static functions we need to take
        care of: <function>properties</function> and <function>styles</function>.
          <code>pb-clipboard</code> has just a single property: the label to display above the copy
        text. Nevertheless it needs to explicitly declare properties inherited from pbMixin which is
        done via <code>...super.properties</code> notation.</para>
      <programlisting language="js" xml:space="preserve">
static get properties() {
        return {
            /**
             * Label to display above the text to be copied
             */
            label: {
                type: String
            },
            ...super.properties
        };
    }
      </programlisting>

      <para>You probably noticed that the button we added in the <function>render</function>
        function specifies what to do upon click event via <code>click</code> attribute:
          <code>@click="${this._copy}"</code>. A protected <function>_copy</function> function of
        the element is called in such case and for our simple <code>pb-clipboard</code> element it
        provides its core <emphasis>copy-to-clipboard</emphasis> functionality.</para>
      <programlisting language="js" xml:space="preserve">
/**
* Copy text content from the &lt;slot> to the clipboard
*/

    _copy() {
        const slot = this.shadowRoot.querySelector('slot');
        
        // first import nodes from the slot into a temporary div
        const content = document.createElement('div');
        slot.assignedNodes().forEach((node) => {
            content.appendChild(document.importNode(node, true));
        });
        
        // copy the innerText of the temp div into the clipboard
        navigator.clipboard.writeText(content.innerText);
    }
      </programlisting>

      <para>We glanced over yet another interesting function invoked in the <code>render</code>
        method. <code>translate</code>, which accepts as an argument a key identifying a
        corresponding label in i18n language files. It could be one of keys shipping with TEI
        Publisher, but here, for a new component we need a more specific label, presenting the user
        with a short, informative text to be displayed when hovering over
          <emphasis>copy-to-clipboard</emphasis> button. Obviously, the label should change in line
        with the language setting for the whole application, which is why we need the i18n module in
        the first place.</para>
      <programlisting language="js" xml:space="preserve">
        title="${translate('clipboard.copy')}"
      </programlisting>
      <para>Please refer to the chapter on <link linkend="i18n">i18n</link> for in-depth discussion
        of the subject. Here we'll just mention that additional language files for new components
        should be placed in <filename>i18n/app</filename>, mimicking the location and format of
        Publisher.</para>
      <programlisting language="js" xml:space="preserve">
{
  "clipboard": {
     "label": "Quote  as:",
     "copy": "Click to copy to clipboard"
  }
}
      </programlisting>
      <para>And one last job is a little bit of styling to make things pretty.</para>
      <programlisting language="js" xml:space="preserve">
static get styles() {
        return css`
            :host {
                display: block;
            }
            h3 {
                margin: 0;
                font-size: .85em;
                font-weight: normal;
                color: #3a3a3a;
            }
            div {
                display: flex;
                align-items: center;
                padding: 0 16px;
            }
        `;
    }
      </programlisting>
      <para>The final directive at the very bottom of <filename>pb-clipboard.js</filename> is
        necessary to register the custom element with the browser.</para>
      <programlisting language="js" xml:space="preserve">
        customElements.define('pb-clipboard', PbClipboard);
      </programlisting>
    </section>
    <section>
      <title>Testing pb-clipboard</title>
      <para>Have a look at the supplied <filename>index.html</filename> example. Run <code>npm
          start</code> to run a simple <link xlink:show="new"
          xlink:href="https://www.npmjs.com/package/es-dev-server">local server</link> instance
        which allows to test our developments as we work on them without bundling.</para>
      <para>Opening <filename>index.html</filename> with this server you can see
          <tag>pb-clipboard</tag> in action.</para>
      <programlisting language="html" xml:space="preserve">
&lt;html>
    &lt;head>
        &lt;title>Using pb-clipboard&lt;/title>
        &lt;style>
            pb-clipboard {
                margin-bottom: 20px;
            }
        &lt;/style>
        &lt;script type="module" src="src/pb-clipboard.js">&lt;/script>
    &lt;/head>
    &lt;body>
        &lt;h1>Using pb-clipboard&lt;/h1>
        &lt;pb-clipboard label="Quote as:">John Doe: "The miracles of foobar", Paradise Publishers, Little Village, Stardate 46254.7&lt;/pb-clipboard>
        &lt;input type="text" name="test-clipboard" value="" size="60">
    &lt;/body>
&lt;/html>
      </programlisting>
      <para>In order to use the element, you need to import the component code into your HTML page,
        as demonstrated with the <tag>script</tag> and
        <code>src="src/pb-clipboard.js"</code>.</para>
      <para>It's all that is needed to use <tag>pb-clipboard</tag> as any other HTML element. Its
        label property is specified via <code>@label</code> attribute and the copy text is just the
        text content of the element.</para>
      <para>Pressing the button copies the citation text from the page and, just to test, you can
        paste it into the input box below.</para>
      <figure>
        <title>pb-clipboard in action on the es-dev-server</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="pb-clipboard-action.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>API documentation</title>
      <para>Implementing a new feature is only half of the task - and sometimes the easier bit. All
          <code>pb-components</code> come with their API documentation and most of them also with
        one or more Demo showcases. Have a look e.g. at <tag>pb-collapse</tag> component for a
        simple one and compare with much more elaborate sections devoted to
          <tag>pb-toggle-feature</tag> or <tag>pb-select-feature</tag>.</para>
      <figure>
        <title>Initial part of the API tab of pb-collapse documentation</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="api-docs.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>API documentation is generated automatically by <code>npm docs</code> task. You just
        need to add <link xlink:show="new"
          xlink:href="https://www.npmjs.com/package/web-component-analyzer#%E2%9E%A4-how-to-document-your-components-using-jsdoc"
          >documentation-style comments</link> in your code. Example below illustrates how to nest
        code examples or specify slots and events so they are picked by the documentation
        generator.</para>
      <programlisting language="js" xml:space="preserve">
/**
 * This is a documentation-style comment
 *
 * with code example
 * ```html
 * &lt;pb-foo>
 *   &lt;slot>&lt;/slot>
 *   &lt;div slot="foo-content">
 *       Foo bar
 *   &lt;/div>
 * &lt;/pb-foo>
 * ```
 * slots specification:
 *
 * @slot - unnamed default slot
 * @slot foo-content - content to be shown when foo happens
 *
 * events specification:
 * 
 * @fires pb-foo-open - Fires opening the foo section
 */
      </programlisting>
      <section>
        <title>Demo</title>
        <para>We encourage you to prepare a demo entry for each newly created component. Demo
          ideally presents one or more use case examples which illustrate where and how would you
          use a component. Keep the demo page simple and minimal, so other elements do not obstruct
          understanding the code.</para>
        <figure>
          <title>Demo file for pb-clipboard</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="api-docs-demo.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Save your demo files in <filename>demo</filename> directory and register it in
            <filename>demo/demos.json</filename> with the demo filename and your chosen label for
          the tab (but please stick to Demo if you only have one).</para>
        <programlisting language="js" xml:space="preserve">
"pb-collapse": {
  "demo/pb-collapse.html": "Demo"
}
        </programlisting>
        <para>If you supply a number of demo files, choose meaningful labels for tabs, e.g.</para>
        <programlisting language="js" xml:space="preserve">
"pb-toggle-feature": {
  "demo/pb-toggle-feature.html": "Server-side with pb-view",
  "demo/pb-toggle-feature2.html": "Client-side",
  "demo/pb-toggle-feature3.html": "Server-side with pb-load"
}
        </programlisting>
      </section>
    </section>
    <section>
      <title>Bundling and distribution</title>
      <para>Any new component <emphasis role="bold">must</emphasis> be explicitly imported by
          <filename>pb-extension-bundle.js</filename>.</para>
      <programlisting language="js" xml:space="preserve">
        import './src/pb-clipboard.js';
      </programlisting>
      <para>Run <code>npm build:production</code> to generate a distribution bundle. The generated
        library (located in <filename>dist</filename>) will include everything, including the
        version of the <code>pb-components</code> library you are building upon and all
        dependencies. As a result, you can use it as a drop-in replacement for
          <code>pb-components</code> package: in your custom project, for TEI Publisher itself or
        Publisher-generated custom apps.</para>
    </section>
    <section>
      <title>Using pb-extension-bundle in TEI Publisher or other apps</title>
      <para>The created library can be used as a drop-in replacement for the default
          <code>pb-components</code> library.</para>
      <para>To do so:</para>
      <procedure>
        <step>
          <para>clone <code>tei-publisher-app</code> or the generated app you would like to
            modify</para>
        </step>
        <step>
          <para>edit <filename>package.json</filename> and replace the dependency for
              <parameter>@teipublisher/pb-components</parameter> with the replacement library</para>
        </step>
        <step>
          <para>edit <filename>build.properties</filename> and change
              <parameter>scripts.dir</parameter> to point to the replacement library</para>
        </step>
        <step>
          <para>call <code>ant</code> to build <code>tei-publisher-app</code></para>
        </step>
      </procedure>

      <para> For example, to use the git source of <code>pb-extension-template</code> in
          <filename>package.json</filename>, change the dependencies as follows: </para>
      <programlisting language="js" xml:space="preserve">
"dependencies": {
   "@teipublisher/pb-extension-template": "git+https://github.com/eeditiones/pb-extension-template#master"
} 
        </programlisting>
      <para>then change <filename>build.properties</filename> to contain: </para>
      <programlisting language="js" xml:space="preserve">scripts.dir=node_modules/@teipublisher/pb-extension-template/dist</programlisting>

      <para>Building <code>tei-publisher-app</code> should then copy scripts and resources from
          <code>pb-extension-template</code> instead of <code>pb-components</code>.</para>

      <note>
        <title>Note</title>
        <para>Make sure to adjust the repository link and name of the extension module to the one
          you created. Example above assumes working directly with
            <code>pb-extension-template</code> but it's unlikely to be the case in real life.</para>
      </note>
    </section>

  </section>

  <section xml:id="embedding">
    <title>Embedding TEI Publisher in other systems</title>
    <para>Since version 6.0, all <code>pb-components</code> can be used <emphasis>outside</emphasis>
      TEI Publisher itself. The components can be embedded into any environment, e.g. a CMS or blog
      software (like WordPress or Drupal) or integrated into any modern front-end framework (like
      vue, react or angular). All that is needed is a TEI Publisher instance available on the web
      which stores the source TEI and provides a communication endpoint for the components to talk
      to.</para>

    <section>
      <title>Live Examples</title>
      <para>The embedded example below demonstrates such a use case: it provides a sandbox running
        on <link xlink:show="new" xlink:href="https://codepen.io">codepen.io</link> but communicates
        with the TEI Publisher instance on <link xlink:show="new"
          xlink:href="https://teipublisher.com">teipublisher.com</link> which stores the documents.
        The magic happens in the <code>endpoint</code> attribute passed to <tag>pb-page</tag>, which
        tells the components where to talk to:</para>
      <programlisting role="codepen" xlink:href="wolfgangmm#YzXEvvw"/>
      <para>You can actually edit the code above: for example, try to change the path for the first
        document to <filename>test/F-rom.xml</filename> and the odd to <code>shakespeare</code>. See
        how the live view changes?</para>
      <para>And if you would like to read <emphasis>Romeo and Juliet</emphasis> in two-column mode,
        just add <code>column-separator=".tei-cb"</code> to the main <tag>pb-view</tag>.</para>
    </section>

    <section>
      <title>Retrieving the whole document as a simple HTML</title>
      <para>Embedding results of applying Processing Model transformation on a document is even
        simpler. Behind the scenes, TEI Publisher has a separate library part, which is essentially
        an implementation of the TEI processing model. This library can be used independently to
        retrieve the entire content of a TEI document as HTML, transformed through an ODD with
        processing instructions.</para>
      <para>All you need is a small XQuery which calls the library modules, setting the correct
        source document and ODD. Fortunately, TEI Publisher already contains a boilerplate XQuery
        script for this job, which you can call as follows in your browser:</para>
      <para><link xlink:show="new"
          xlink:href="https://teipublisher.com/exist/apps/tei-publisher/modules/lib/transform.xql?doc=test/F-rom.xml&amp;odd=shakespeare.odd"
          >https://teipublisher.com/exist/apps/tei-publisher/modules/lib/transform.xql?doc=test/F-rom.xml&amp;odd=shakespeare.odd</link></para>
      <para>This will retrieve the content of Shakespeare's <emphasis>Romeo and Juliet</emphasis> as
        an HTML page, transformed through the odd <filename>shakespeare.odd</filename>. For
        embedding an entire document in an iframe or similar, this should already be enough.</para>
    </section>
    <section>
      <title>Embedding webcomponents for navigation</title>
      <para>For longer documents, embedding the entire content in a page may not be too
        user-friendly. A better way is to use the library of webcomponents provided by TEI
        Publisher. This way, we can show the content page by page or division by division, allowing
        the reader to navigate between sections.</para>
      <programlisting role="codepen" xlink:href="wolfgangmm#ExVQKBK"/>
      <para>Because webcomponents are part of the HTML5 standard and supported natively by most
        modern browsers, we can easily import the component library which is at the core of the TEI
        Publisher app and reuse the components it provides in other contexts. They should work in
        any HTML5 page, no matter if it was written by hand, is generated by PHP, Python or a
        CMS.</para>
      <para>For a start, the page should import two scripts in its header:</para>
      <programlisting language="html" xml:space="preserve"><![CDATA[<script src="https://unpkg.com/@webcomponents/webcomponentsjs@2.4.3/webcomponents-loader.js"></script>
<script type="module" src="https://unpkg.com/@teipublisher/pb-components@latest/dist/pb-components-bundle.js"></script>]]></programlisting>
      <para>This imports necessary <code>pb-components</code> libraries from <code>unpkg.com</code>
        CDN which is considered the best practice for web sites.</para>
      <para>The second <tag>script</tag> tag imports all the components provided by TEI Publisher.
        Note that here <code>pb-components@latest</code> points to the latest available bundle, but
        you could specify a concrete version number to make sure your website uses a fixed
        release.</para>

      <para>Now let's actually use the components to display Shakespeare's <emphasis>Romeo and
          Juliet</emphasis>: in the HTML <tag>body</tag>, include the following snippet: </para>
      <programlisting language="html" xml:space="preserve">&lt;pb-page endpoint="https://teipublisher.com/exist/apps/tei-publisher">
    &lt;pb-document id="document1" path="test/F-rom.xml" odd="shakespeare">&lt;/pb-document>
    &lt;!-- Navigate to previous page -->
    &lt;pb-navigation direction="backward" unit="page" keyboard="left">
      &lt;paper-button>
         &lt;iron-icon icon="icons:chevron-left">&lt;/iron-icon>
      &lt;/paper-button>
    &lt;/pb-navigation>
    &lt;pb-view id="view1" src="document1" view="page">&lt;/pb-view>
    &lt;!-- Navigate to next page -->
    &lt;pb-navigation direction="forward" unit="page" keyboard="right">
      &lt;paper-button>
         &lt;iron-icon icon="icons:chevron-right">&lt;/iron-icon>
      &lt;/paper-button>
    &lt;/pb-navigation>
&lt;/pb-page></programlisting>
      <para>In the <tag>pb-page</tag>
        <code>endpoint</code> attribute we need to provide a critical piece of information: the URL
        of the TEI Publisher instance for all the components to communicate with. If you have set up
        your own instance of eXist-db and TEI Publisher, you should change the URL <emphasis>to
          point to your instance</emphasis>. This is important because the components will expect
        the documents you want to display to be stored in the same instance.</para>
      <para><tag>pb-document</tag> defines the document to be displayed. The path is relative to the
        data root of the TEI Publisher instance. It also specifies the ODD to be used for the
        transformation.</para>
      <para><tag>pb-view</tag> is the main component for displaying the transformed content. It
        references the <tag>pb-document</tag> to use as source in its <option>src</option>
        attribute. The Shakespeare does tag page breaks, so we switch to page-by-page view via the
          <option>view</option> attribute to show the user only one page at a time. The default
        would be to use a division-by-division view (<code>view="div"</code>), but you could also
        request the entire content at once using <code>view="single"</code>.</para>
      <para><tag>pb-navigation</tag> adds forward/backward navigation buttons to the page, allowing
        the user to switch to the next/previous page of the document. You can use various types of
        buttons, but in this case we're choosing a <tag>paper-button</tag> element with a chevron
          <tag>iron-icon</tag> (both <tag>paper-button</tag> and <tag>iron-icon</tag> are part of
        the standard <link xlink:show="new"
          xlink:href="https://www.webcomponents.org/author/PolymerElements">Polymer elements
          library</link>).</para>
    </section>
  </section>


  <section xml:id="new-vocabulary">
    <title>Adding a custom vocabulary</title>
    <para>As discussed in the opening chapter, publishing a corpus of documents online is much more
      than just transforming a single source document into the desired output format. To fully
      support a new XML vocabulary in TEI Publisher several aspects need to be adressed:</para>
    <itemizedlist>
      <listitem>
        <para>ODD with processing models</para>
      </listitem>
      <listitem>
        <para>default view and page template</para>
      </listitem>
      <listitem>
        <para>navigation, breadcrumbs and table of contents</para>
      </listitem>
      <listitem>
        <para>search and filtering: full text index definitions, facets and fields</para>
      </listitem>
    </itemizedlist>
    <para>ODD and processing models within it govern how the document in your new vocabulary will be
      transformed into a range of available output formats: HTML, ePub etc.</para>
    <para>All other aspects are interconnected and depend on the understanding what constitutes the
      basic unit of the text: TEI primarily considers <emphasis>divisions</emphasis> or
        <emphasis>pages</emphasis>, DocBook rather <emphasis>sections</emphasis>. Therefore
      navigation for TEI document will be switching between <tag>div</tag>s or reconstructed XML
      fragments between subsequent <tag>pb</tag>s, while talking about pages in DocBook documents
      makes no sense and <tag>section</tag>s are the main structural units.</para>
    <para>This structure has its consequences for further aspects: generating TOC in TEI will
      analyze nested <tag>div</tag>/<tag>head</tag> structures but only
        <tag>section</tag>/<tag>title</tag> in DocBook. Likewise, KWIC display in TEI will be
      showing matches in <tag>div</tag> context but <tag>section</tag> in DocBook, so Lucene indexes
      need to be defined on these elements in their appropriate namespaces. Ditto for facets and
      fields used for sorting and filtering.</para>
    <para>Sections below will explain where and how to customize these aspects in more
      detail.</para>
    <section xml:id="new-vocabulary-odd">
      <title>ODD</title>
      <para> Create a new, blank ODD file which is not chained to any other ODD and add
          <tag>elementSpec</tag>s for its elements. Make sure that you specify correct namespace for
        your vocabulary. Optionally, you can also specify an external CSS file with style
        declarations for classes and elements you will be using in processing models of your
        ODD.</para>
      <para>See how it looks in the ODD for DocBook.</para>
      <figure>
        <title>ODD for DocBook</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="new-vocabulary-odd.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>When adding models into the custom ODD for your vocabulary it is recommended that at
        least one element applies the <parameter>document</parameter> behaviour. Usually it will be
        the top level element or the main content-bearing one (like <tag>article</tag> in
        DocBook).</para>
      <para>This is not strictly required but for print output via LaTeX or FO the
          <parameter>document</parameter> behaviour specifies default prologue governing basic setup
        for PDF. If you refer to the <filename>docbook.odd</filename> you will note that the same
        effect is achieved by explicitly defining the prologue in the <tag>pb:template</tag> for
          <parameter>article</parameter>.</para>
      <section>
        <title>Case study: foo vocabulary</title>
        <para>Let's consider an imaginary vocabulary called <emphasis>foo</emphasis>. All documents
          in this vocabulary will belong to the <code>http://foo.io</code> namespace. Simple
          document could look as follows:</para>
        <programlisting language="xml" xml:space="preserve">
        &lt;fooStart xmlns="http://foo.io">
          &lt;foo>My foo document&lt;/foo>
          &lt;bar>About something very important for foo community.&lt;/bar>
        &lt;/fooStart>
        </programlisting>
        <para>Let's save this document in the <filename>playground</filename> collection as
            <filename>foo.xml</filename>.</para>
        <para>Unfortunately a request to retrieve this document in Publisher fails with
            <emphasis>the server did not return any content</emphasis> error message.</para>
        <programlisting>http://localhost:8080/exist/apps/tei-publisher/playground/foo.xml</programlisting>
        <para>Fixing this will require creating a new ODD for <emphasis>foo</emphasis>
          vocabulary.</para>
        <para>Create a new ODD as described previously. Use <parameter>document</parameter>
          behaviour for <tag>fooStart</tag> element and perhaps <tag>inline</tag> with an
            <tag>outputRendition</tag> set to <parameter>italic</parameter> for <tag>foo</tag>
          element. Please note to specify the ODD for your vocabulary.</para>


        <para>Very bare bones ODD file for a fictional <emphasis>Foo</emphasis> vocabulary could
          look as follows:</para>
        <figure>
          <title>ODD for Foo</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="foo-odd.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Or, in XML form:</para>
        <programlisting language="xml" xml:space="preserve">
&lt;schemaSpec start="fooStart" ident="foo" ns="http://foo.io"> 
   &lt;elementSpec ident="foo" mode="add">
       &lt;model behaviour="inline">
           &lt;outputRendition>font-style: italic;&lt;/outputRendition>
       &lt;/model>
   &lt;/elementSpec>
   &lt;elementSpec ident="fooStart" mode="add">
       &lt;model behaviour="document"/>
   &lt;/elementSpec>
&lt;/schemaSpec>
        </programlisting>
        <para>With this in place we could reformulate our request to explicitly specify the ODD to
          use and a <parameter>single</parameter> view.</para>
        <programlisting>http://localhost:8080/exist/apps/tei-publisher/playground/foo.xml?odd=foo&amp;view=single</programlisting>
        <figure>
          <title>foo.xml rendered with foo.odd in single view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="foo-single-view.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <note>
          <title>Note</title>
          <para>It is necessary to use <parameter>single</parameter> view along with the
              <parameter>foo.odd</parameter>. Otherwise, the app default view would be used, which
            in TEI Publisher is normally set to <parameter>div</parameter>. As we already mentioned,
            implementation of view parameters needs to be vocabulary-specific to work. Since
              <emphasis>foo</emphasis> vocabulary doesn't yet have navigation customized, TEI
            Publisher will fall back to TEI and try to locate <tag>tei:div</tag> elements, which
            obviously cannot be found in our test document in foo namespace.</para>

        </note>
      </section>

    </section>
    <section>
      <title>Default view and page template</title>
      <para>Rendering of the document is governed by a number of parameters, particularly
          <parameter>view</parameter>, <parameter>ODD</parameter> and
          <parameter>template</parameter>:</para>
      <para>Even when these parameters are not explicitly specified, TEI Publisher and apps
        generated from it, will fall back to the default values specified in
          <filename>modules/config.xqm</filename>.</para>

      <itemizedlist>
        <listitem>
          <para>ODD: <code>$config:default-view</code></para>
        </listitem>
        <listitem>
          <para>view: <code>$config:default-view</code></para>
        </listitem>
        <listitem>
          <para>template: <code>$config:default-template</code></para>
        </listitem>
      </itemizedlist>
      <para>Alternative way to specify these would be using a <link linkend="pi-config">processing
          instruction</link> in the foo.xml document itself.</para>
      <programlisting language="xml" xml:space="preserve">
        &lt;?teipublisher odd="foo.odd" view="single" template="view.html"?>
      </programlisting>
    </section>
    <section xml:id="new-vocabulary-lucene">
      <title>Lucene configuration</title>
      <para>eXist-db and TEI Publisher make extensive use of Lucene indexing engine. In particular
        search, navigation, sorting and filtering heavily depend on full text indexes, facets and
        fields therefore it is paramount to specify these correctly for your data
        collection.</para>
      <para>Supporting a new vocabulary, make sure to add its namespace on the <tag>index</tag>
        element in <filename>collection.xconf</filename>.</para>
      <programlisting language="xml" xml:space="preserve">
&lt;index xmlns:tei="http://www.tei-c.org/ns/1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dbk="http://docbook.org/ns/docbook">
      </programlisting>
      <para>Beyond this minor adjustment, adding a new vocabulary does not differ in creation and use of facets and fields.</para>
    </section>
    <section xml:id="new-vocabulary-navigation">
      <title>Navigation</title>
      <para>We have extensively covered modifications to the ODD and page templates in earlier
        chapters. In case of vocabularies without out-of-the-box Publisher support it is necessary
        to customize the navigation as well. Tacit understanding of document's structure is critical
        for many kinds of user interactions - from browsing through pages to creating the table of
        contents.</para>
      <para><filename>modules/navigation.xql</filename> is the main "control room" for all tasks
        related to navigation. You will note that it imports custom modules for all supported
        vocabularies: <emphasis>TEI</emphasis>, <emphasis>JATS</emphasis> and
          <emphasis>DocBook</emphasis>. All requests are dispatched to specialized modules,
        depending on the namespace of the document (cf. <function>nav:document-type</function>
        function).</para>
      <programlisting language="xquery" xml:space="preserve">
module namespace nav="http://www.tei-c.org/tei-simple/navigation";

import module namespace tei-nav="http://www.tei-c.org/tei-simple/navigation/tei" at "navigation-tei.xql";
import module namespace jats-nav="http://www.tei-c.org/tei-simple/navigation/jats" at "navigation-jats.xql";
import module namespace docbook-nav="http://www.tei-c.org/tei-simple/navigation/docbook" at "navigation-dbk.xql";
      </programlisting>
      <para>Customizing yet unsupported vocabulary will require:</para>
      <itemizedlist>
        <listitem>
          <para>create a new navigation module for the new vocabulary (e.g.
              <filename>navigation-foo.xql</filename>; it should implement all the functions that
              <function>navigation.xql</function> dispatches to; you can use
              <filename>navigation-tei</filename> as a starting point for customization</para>
          <para>import it into <filename>navigation.xql</filename></para>
        </listitem>
        <listitem>
          <para>adjust <function>nav:document-type</function> function</para>
        </listitem>
        <listitem>
          <para>adjust <function>nav:get-root</function></para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="new-vocabulary-search">
      <title>Search</title>
      <para>Full text search is realized via the same modular approach that governs navigation.
          <filename>modules/query.xql</filename> is the main "control room", dispatching requests to
        functions in specialized modules. See implementation of <filename>db-query.xql</filename> or
          <filename>tei-query.xql</filename> before creating a dedicated module for your vocabulary.
        Make sure to import your module into <filename>query.xql</filename>.</para>
    </section>

  </section>

  <section xml:id="faq">
    <title>Frequently Asked Questions</title>
    <section>
      <title>How can I include elements located elsewhere (in the same or another document)?</title>
      <para>For example, it is common practice to keep notes in the back of the document and
        reference them using ref. When processing the ref, you want to include the note's content
        into the <function>note</function> behaviour:</para>
      <programlisting language="xml" xml:space="preserve">&lt;elementSpec mode="change" ident="ref"&gt;
  &lt;model behaviour="note"&gt;
    &lt;param name="place" value="'margin'"/&gt;
    &lt;!-- Look up the note by xml:id --&gt;
    &lt;param name="content" value="id(substring-after(@target, '#'), root($parameters?root))/node()"/&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
      <para>Here we use the <function>fn:id</function> XPath function to look up the element whose
        ID is given in the <parameter>@target</parameter> attribute. It will usually start with an
        '#', so we have to strip this out. The second parameter to <function>fn:id</function>
        specifies the document-node to search for the id. Note that we're using
          <parameter>$parameters?root</parameter> here and not just <function>root(.)</function>.
        See next topic below for an explanation.</para>
    </section>
    <section>
      <title>How do I navigate to the root of the document in XPath?</title>
      <para>Normally you would get to the document-node of the current document by calling
          <function>root(.)</function> in an XPath within the ODD. This works, but there is a
        caveat:</para>
      <para>TEI Publisher will not always pass the entire document to the ODD! For example, if
        documents are viewed page by page, TEI Publisher will first construct a virtual TEI document
        containing only the relevant content of the page. This is necessary to make sure the content
        is well-formed XML. Calling <function>root(.)</function> may thus not return the original
        document-node but just the constructed root.</para>
      <para>To compensate for this, TEI Publisher always passes in an external parameter pointing to
        the original document-node. It can be accessed via the variable
          <parameter>$parameters?root</parameter>.</para>
    </section>
    <section>
      <title>Why does my added model not have an effect?</title>
      <para>You added another model rule to an elementSpec but it does not seem to have any effect.
        This might be due to the rules for selecting a model:</para>
      <para>The processor walks through all models in sequence and stops at the first one which
        either has a matching <parameter>@predicate</parameter> and/or
          <parameter>@output</parameter> or neither of both. <emphasis role="bold">Order is
          important</emphasis>! If your default model (the one without predicate or output) is
        placed in front of your more specific models, it will always match:</para>
      <programlisting xml:space="preserve">&lt;elementSpec mode="change" ident="hi"&gt;
  &lt;model behaviour="inline"/&gt;
  &lt;model predicate="@rend='bold'" behaviour="inline"&gt;
    &lt;outputRendition&gt;font-weight: bold;&lt;/outputRendition&gt;
  &lt;/model&gt;
&lt;/elementSpec&gt;</programlisting>
    </section>
    <section>
      <title>Page view doesn't work</title>
      <para>Displaying documents page by page requires that page breaks are encoded. In TEI you are
        expected to explicitly place <tag>pb</tag> elements where each page begins.</para>
      <para>Please note that certain vocabularies, like DocBook, do not recognize the concept of a
          <emphasis>page</emphasis> at all, so page view cannot possibly work for these.</para>
    </section>
    <section>
      <title>Why does my document show 'server did not return any content' error message?</title>
      <para>Please bear in mind that while TEI Publisher aims to be a universal tool, the specific
        components may make certain assumptions about data they are getting and if your documents do
        not follow the same encoding conventions it may be required to adjust parameters passed to
        the components from the page template - or add required information in the document.</para>
      <para>For example - table of content component assumes that the document structure is
        represented by means of nested <tag>div</tag> elements and section titles are given
          in <tag>head</tag> element. If your project rather chooses numbered divisions
          (<tag>div1</tag>, <tag>div2</tag>) etc it may be advisable to adjust this to avoid
        customizing all navigation, table of contents and so on, but it is one of very rare cases
        where TEI Publisher exposes any predilection for a particular flavour of TEI.</para>
      <para>Similarly, template with aligned transcription/translation panels is parametrized with
        an XPath expression pointing to relevant fragments of the document which store the
        transcription and translation. This expression most probably will have to be adjusted
        (unless of course you also have Latin texts with Polish translation structured in a similar
        way).</para>
    </section>
    <section>
      <title>Some of my Word formatting is not preserved upon import</title>
      <para>When uploading a Word document to Publisher it is converted to TEI, using a custom ODD
        for the tranformation. Please note that the focus of this conversion is to preserve textual
        content, structure and basic semantics of the text, not provide authoritative mapping of
        complete set of MS Word features to TEI. Consider customizing the
          <filename>docx.odd</filename> if you need a mapping for a particular Word feature to
        TEI.</para>
    </section>
    <section>
      <title>How do I log in?</title>
      <para>On a fresh install, TEI Publisher creates a user <filename>tei</filename> with a
        password <filename>simple</filename>. You can change this password (and it is recommended to
        do so, if your eXist instance runs on a server and would be accessible to other
        users).</para>
      <para>When generating your own application, the generator form requires you to fill in a user
        and password for the new application. Likewise, this password can be later changed via eXist
          <filename>Usermanager</filename>.</para>
    </section>
  </section>
  <section xml:id="roadmap">
    <title>Roadmap</title>
    <para>Here's a list of ideas we'd like to see incorporated into TEI Publisher. These are in
      various stages of development - some already advanced, some in conceptual phase, some waiting
      for implementation.</para>
    <section>

      <title>Features</title>
      <variablelist>
        <varlistentry>
          <term>Wider coverage of input/output formats</term>
          <listitem>
            <para>Docx</para>
          </listitem>
          <listitem>
            <para>InDesign</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Interoperability</term>
          <listitem>
            <para>DTS</para>
          </listitem>
          <listitem>
            <para>CQL</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <variablelist>
        <varlistentry>
          <term>Custom app maintenance</term>
          <listitem>
            <para>Refactoring reusable parts of the TEI Publisher into library modules</para>
          </listitem>
          <listitem>
            <para>Switch to lightweight custom app model relying on shared libraries</para>
          </listitem>
          <listitem>
            <para>Custom app control-center for automated app updates and management</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ODD editing</term>
          <listitem>
            <para>UI and usability improvements</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Showcases</term>
          <listitem>
            <para>Extend coverage of the document and layout examples: prosopographical resources,
              dictionaries, linguistic corpora...</para>
          </listitem>
          <listitem>
            <para>Complete app showcases for other domains</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Editing</term>
          <listitem>
            <para>Form-based editing for document metadata</para>
          </listitem>
          <listitem>
            <para>Stand-off and inline editing via custom components, eg. for dates, people or
              places</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Further generalizations</term>
          <listitem>
            <para>Improve state management and component communication</para>
          </listitem>
          <listitem>
            <para>Navigation, search, browse, creation of virtual subcollections </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Documentation and tutorials</term>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</article>
