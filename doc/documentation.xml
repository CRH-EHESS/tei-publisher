<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 file:/Users/wolf/Source/TEI-Simple/teisimple.xsd">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>TEI Processing Model Toolbox</title>
                <author>Wolfgang Meier</author>
            </titleStmt>
            <publicationStmt>
                <publisher>eXistSolutions GmbH</publisher>
            </publicationStmt>
            <sourceDesc>
                <p>App documentation</p>
            </sourceDesc>
        </fileDesc>
    </teiHeader>
    <text>
        <body>
            <div>
                <head>TEI Processing Model Toolbox</head>
                <div>
                    <head>Introduction</head>
                    <p>The TEI Processing Model (PM) extends the TEI ODD specification format with a processing model for
                    documents. That way intended processing for all elements can be expressed within the TEI vocubulary itself.
                    It aims at the
                    XML-savvy editor who is familiar with TEI but is not necessarily a developer. The editor knows the logical 
                    structure of the text and maps it to a small set of abstract transformation functions, called
                    "behaviours". Predefined behaviours are, for example, "paragraph", "heading" or "note".</p>
                    <p>Basic styling features can be set directly within the ODD using CSS. The processing model
                    is media-agnostic: rendition styles are transparently translated into the different output media 
                    types like HTML, XSL-FO, LaTeX, or ePUB.</p>
                    <p>At the same time, the processing model implements a clean separation of concerns to improve
                    the workflow between editors, designers and developers. The editor defines how elements are 
                    mapped to behavior functions and specifies basic styling rules, the designer controls the 
                    overall presentation of the material, and the developer concentrates on the general application 
                    framework and—if necessary—supports the editor by providing custom behavior functions as 
                    extension modules.</p>
                    <p>
                        <figure>
                            <graphic url="rahtzrationale.png"/>
                        </figure>
                    </p>
                    <p>A word of warning though: while the processing model was developed as part of the
                TEI Simple initiative, it is not necessarily trivial to comprehend nor "simple" regarding 
                the knowledge and skill it requires.
                The goal rather was to improve workflows and interoperability by providing a 
                minimal abstraction for the processing rules applied to a document. Using the processing model
                definitely simplifies the life of the developer, who often has to write a few thousand lines of code
                just to render a particular TEI document into HTML, only to repeat the same tedious process for PDF output. 
                Last but not least the processing model empowers the scholary editor to create high-quality prototype 
                websites from a given data set without even relying on a developer.</p>
                </div>
                <div>
                    <head>The Toolbox</head>
                    <p>The toolbox does a lot more than just implement the TEI processing model. It consists
                    of the following components:</p>
                    <list type="ordered">
                        <item>
                            A set of library modules to render a TEI document into various output formats, 
                            which can be imported into other applications.
                        </item>
                        <item>
                            The core application to work and experiment with various source documents and processing
                            model instances.
                        </item>
                        <item>
                            An application generator, which takes a processing model instance and creates 
                            a user interface around it, resulting in a standalone web application for a
                            certain corpus of documents.
                        </item>
                    </list>
                    <p>In a strict sense, only the first component implements the processing model specification. 
                        The larger part of the toolbox deals with graphical user interface components, adding
                    pagination, navigation and search features.</p>
                </div>
                <div>
                    <head>Getting Started</head>
                    <p>The toolbox is distributed as an eXist application package, making it easy to install
                    on any local or remote eXist database instance. Just go to the dashboard, open the package
                    manager and install the TEI processing model package from the public repository.</p>
                    <p>Once installed, play around with the provided documents or upload your own via the file
                    upload panel in the right sidebar. You may modify any of the supplied ODD files and see how
                    the rendering changes.</p>
                    <p>To create your own custom ODD, tailored to the data set you are working on, the general 
                        procedure is as follows:</p>
                    <list>
                        <item>Create a new customization</item>
                        <item>Overwrite the standard processing model rules for selected TEI elements or add
                        model rules for elements not handled by the standard ODD.</item>
                        <item>Test your modifications by applying the ODD and rendering a few documents.</item>
                    </list>
                    <p>The steps will be described in detail in the following sections.</p>
                    <div>
                        <head>Create a new customization</head>
                        <p>Create a new customization by entering a name and clicking "Create" at the bottom 
                            of the right sidebar panel listing the available ODDs. Reload the page to see
                            the new ODD appear in the list.</p>
                        <p>Open the created ODD using the "source" button. This will create a new browser tab
                        showing the editor which is part of eXist, called "eXide". The ODD will be loaded into 
                        it.</p>
                        <p>As you can see, the ODD is nearly empty, containing just boilerplate code. However,
                        it imports the standard <code>teisimple.odd</code> within the <code>schemaSpec</code>
                        element:</p>
                        <code lang="xml">&lt;schemaSpec ident="myteisimple" start="TEI teiCorpus" source="teisimple.odd"&gt;</code>
                        <p>This means your new ODD extends the standard <code>teisimple.odd</code>, which 
                        provides useful defaults for the TEI core elements. In general, most of those defaults
                        should be ok and you only need to overwrite a hand full of selected mappings within your
                        own ODD.</p>
                    </div>
                </div>
                <div>
                    <head>Processing Model syntax</head>
                    <div>
                        <head>
                            <gi>model</gi> element</head>
                        <p>
                            <gi>model</gi> element is primarily used to document intended processing for a given element.
                    One or more of these elements may appear directly within an <gi>elementSpec</gi> element specification to
                    define the processing anticipated for that element. Where multiple <gi>model</gi> elements appear, they are
                    understood to document mutually exclusive processing scenarios, possibly for different outputs or 
                    applicable in different contexts. 
                    </p>
                        <p>A processing model defines on an abstract level how a given element may be transformed to produce
                    one or more outputs.
                    The model is expressed in terms of <term>behaviours</term> and their <term>parameters</term>, using high-level
                    formatting concepts, such as <soCalled>block</soCalled>, <soCalled>inline</soCalled>, <soCalled>note</soCalled>
                    or <soCalled>heading</soCalled>. A processing model is thus a template description, used to generate the code
                    needed by the publishing application to process the source document into required output. 
                    </p>
                        <p>
                    Example below depicts a situation where a single model is defined for <gi>app</gi> element. As no @predicate
                    or @output are specified, this model applies for all contexts in which <gi>app</gi> may appear and all possible
                    outputs. Thus for all <gi>app</gi> elements they will be transformed into inline chunks of text containing only
                    contents of <gi>app</gi>'s <gi>lem</gi> child and omitting any possible <gi>rdg</gi> children.
                    <pre>
                                <code lang="xml">&lt;elementSpec mode="change" ident="app"&gt;
 &lt;model behaviour="inline"&gt;
  &lt;param name="content"&gt;lem&lt;/param&gt;
 &lt;/model&gt;
&lt;/elementSpec&gt;
</code>
                            </pre>
                        </p>
                    </div>
                    <div>
                        <head>
                            <gi>model</gi> children and attributes:</head>
                        <p>
                            <list>
                                <item>@predicate: the condition under which this model applies, given as an XPath Predicate Expression</item>
                                <item>@behaviour: names the function which this processing model uses in order to produce output; possible values include: alternate, block, figure, heading, inline, link, list, note, paragraph</item>
                                <item>@output: identifier of the intended output for which this model applies; applies to all output if no @output is present on a <gi>model</gi>
                                </item>
                                <item>@useSourceRendition: whether to obey any rendition attribute which is present in the source document</item>
                                <item>
                                    <gi>param</gi>: allows to pass parameters to @behaviour function; parameters available
                            depend on the behaviour in question; when parameters are not explicitly passed, default values
                            for those are assumed; all behaviour functions use current	element as default content</item>
                                <item>
                                    <gi>outputRendition</gi>: supplies information about the desired output rendition in CSS; its attribute @scope provides a way of defining ‘pseudo-elements’ eg: first-line, first-letter, before, after
                            </item>
                            </list>
                        </p>
                        <p>
                    Simple model explicitly specifying content parameter: for <gi>app</gi> entries only content of its <gi>lem</gi> child is to be displayed (as an inline chunk of text)
                    <pre>
                                <code lang="xml">&lt;elementSpec mode="change" ident="app"&gt;
 &lt;model behaviour="inline"&gt;
  &lt;param name="content"&gt;lem&lt;/param&gt;
 &lt;/model&gt;
&lt;/elementSpec&gt;
</code>
                            </pre>
                        </p>
                        <p>
                    Model specifying output rendition: contents of <gi>ex</gi> elements are to be displayed in italic and wrapped in parentheses
					<pre>
                                <code lang="xml">&lt;elementSpec mode="change" ident="ex"&gt;
 &lt;model behaviour="inline"&gt;
   &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
   &lt;outputRendition scope="before"&gt;content:"(";&lt;/outputRendition&gt;
   &lt;outputRendition scope="after"&gt;content:")";&lt;/outputRendition&gt;
 &lt;/model&gt;
&lt;/elementSpec&gt;</code>
                            </pre>
                        </p>
                        <p>Sometimes different processing models are required for the same element in different contexts. 
                    For example, we may wish to process the <gi>quote</gi> element as an inline italic element when it
                    appears inside a <gi>p</gi> element, but as an indented block when it appears elsewhere. 
                    To achieve this, we need to change the specification for the <gi>quote</gi> element to include
                    two <gi>model</gi> elements as follows:
					<pre>
                                <code lang="xml">&lt;elementSpec mode="change" ident="quote"&gt;
    &lt;model predicate="ancestor::p" behaviour="inline"&gt;
        &lt;outputRendition&gt;font-style: italic;&lt;/outputRendition&gt;
    &lt;/model&gt;
    &lt;model behaviour="block"&gt;
        &lt;outputRendition&gt;left-margin: 2em;&lt;/outputRendition&gt;
    &lt;/model&gt;
&lt;/elementSpec&gt;
</code>
                            </pre>
           The first processing model will be used only for <gi>quote</gi> elements which match the XPath
           expression given as value for the <att>predicate</att> attribute.
           Other element occurrences will use the second processing model. 
            Set of multiple <gi>model</gi> statements is regarded as an alternation and only the 
            first model with @predicatematching current context is applied

<!--
           					<pre>
					<code><elementSpec mode="change" ident="choice">
	<model output="plain" predicate="sic and corr"  behaviour="inline">
		<param name="content">corr[1]</param>
	</model>
	<model output="plain" predicate="abbr and expan" behaviour="inline">
		<param name="content">expan[1]</param>
	</model>
	<model output="plain" predicate="orig and reg" behaviour="inline">
		<param name="content">reg[1]</param>
	</model>
	<model predicate="sic and corr" behaviour="alternate">
		<param name="default">corr[1]</param>
		<param name="alternate">sic[1]</param>
	</model>
	<model predicate="abbr and expan" behaviour="alternate">
		<param name="default">expan[1]</param>
		<param name="alternate">abbr[1]</param>
	</model>
	<model predicate="orig and reg" behaviour="alternate">
		<param name="default">reg[1]</param>
		<param name="alternate">orig[1]</param>
	</model>
</elementSpec></code></pre>
-->
                        </p>
                    </div>
                    <div>
                        <head>
                            <gi>modelSequence</gi> and <gi>modelGrp</gi>
                        </head>
                        <p>
                        Summary of elements that can be used to document one or more processing models for a given element:
                        <list>
                                <item>
                                    <gi>model</gi> describes the processing intended for a specific context
                            </item>
                                <item>
                                    <gi>modelSequence</gi> (sequence of processing models) a group of model elements
                                documenting intended processing models for this element, to be acted upon in sequence
                            </item>
                                <item>
                                    <gi>modelGrp</gi> (processing model group) a group of model elements documenting
                                intended processing models for this element
                            </item>
                            </list>
                        </p>
                        <p>
                    The
                    <gi>modelGrp</gi> element may be used to group alternative <gi>model</gi> elements intended for 
                    a single kind of output. The <gi>modelSequence</gi> element is provided for the case where a sequence 
                    of models is to be processed, functioning as a single unit. Common use case would be to use modelSequence to
                    generate table of contents along with the reading text as shown in the example below:
					<pre>
                                <code lang="xml">&lt;elementSpec mode="change" ident="body"&gt;
&lt;modelSequence&gt;
    &lt;model behaviour="index"&gt;
        &lt;param name="type"&gt;'toc'&lt;/param&gt;
    &lt;/model&gt;
    &lt;model behaviour="block"/&gt;
&lt;/modelSequence&gt;
&lt;/elementSpec&gt;
</code>
                            </pre>
                        </p>
                    </div>
                    <div>
                        <head>Behaviours</head>
                        <p>Most of the processing complexity is hidden behind behaviour functions which were designed
                to cover majority of commonly occurring processing tasks. Function names are wherever possible 
                based on commonly used terms such as 'inline', 'block', 'note' or 'link'.</p>
                        <p>Behaviour functions accept a range of parameters, depending on the function in question. Where these
                parameters are left unspecified in the <gi>model</gi>, default values are used.</p>
                        <p>MORE ON BEHAViours goes here</p>
                    </div>
                    <div>
                        <head>Output formatting options</head><!--
<p>This component of an element specification describes the rendering or appearance intended for all occurrences of the element in a specified context for a specified type of output. The <gi>rendition</gi> element, by contrast, describes the actual rendering or appearance of all occurrences of the specified element in a source document. The <att>useSourceRendition</att> attribute may however be used to indicate that formatting information provided by a <gi>rendition</gi> element is to be  combined with any provided by an <gi>outputRendition</gi> element.</p>
<p>It is strongly recommended that the W3C Cascading Stylesheet language (CSS2 or later) be used to express the required formatting information.</p>
-->
                        <p>
The intended rendering for a particular behaviour of a processing model may be documented in one or all of the three following ways. Firstly, the @CSSclass attribute may be used to specify the name of a CSS style in some associated CSS stylesheet which is to be applied to each occurrence of a specified element found (in a given context, for a specified output). Secondly, the attribute @useSourceRendition may be used to indicate that the rendition specified in the source document should be applied. Thirdly, the styling to be applied may be specified explicitly as content of a child <gi>outputRendition</gi> element.
</p>
                        <p>
When more than one of these options is used, they are understood to be combined in accordance with the rules for multiple declaration of the styling language used.
</p>
                        <p>
It is strongly recommended that use <gi>outputRendition</gi> should be limited to strictly editorial decisions, such as 'conjectures are to be displayed in square brackets' and not as means to record all typesetting and layout specific design choices.</p>
                    </div>
                    <div>
                        <head>Best Practice Recommendations</head>
                        <list>
                            <item>
                                <p>While the ODD may describe the rendition of an element using CSS, this 
                                should be used with care: styling imposed by the ODD should be generic
                            and not interfere with application-specific design choices.</p>
                                <p>For example, defining a font family for a certain element in the ODD
                                makes it difficult for web designers to set the font via an external 
                                stylesheet.</p>
                                <p>The HTML as well as the FO output function libraries provide ways to
                                customize the styling through additional, user-supplied CSS.</p>
                            </item>
                        </list>
                    </div>
                </div>
                <div>
                    <head>Extension Modules</head>
                    <p>Where possible, developers should stick to the standard processing model functions for
                    defining behaviours. However, there might be situations in which one has to generate 
                    a specific type of output, which is not handled by the default function module. To facilitate this,
                    the implementation allows additional extension modules to be configured:</p>
                    <p>The last parameter to <code>pmu:process</code> may be a sequence of XQuery maps defining
                        extension modules to be loaded. Each map should specify the namespace URI, prefix and
                        location of an XQuery module to be imported. For example:</p>
                    <code lang="xquery">map {
    "uri": "http://www.tei-c.org/tei-simple/xquery/ext-html",
    "prefix": "ext",
    "at": "../modules/ext-html.xql"
};</code>
                    <p>defines an extension module stored in the <code>../modules/ext-html.xql</code>
                    XQuery module. Whenever the library tries to locate a processing model function
                    for a given behaviour, it will <hi rendition="simple:bold">first</hi> check any extension
                    module it knows to see if it contains a matching function. One can thus 
                        <hi rendition="simple:bold">overwrite</hi> the default
                    functions as well as define new ones.</p>
                    <p>To be recognized by the library, an extension function needs to accept at least
                    3 default arguments, plus any number of custom parameters (to be passed in the 
                    behaviour attribute).</p>
                    <p>For example, our extension module <code>ext-html.xql</code> may look as follows:</p>
                    <code lang="xquery">xquery version "3.1";

(:~
: Non-standard extension functions, mainly used for the documentation.
:)
module namespace pmf="http://www.tei-c.org/tei-simple/xquery/ext-html";

declare namespace tei="http://www.tei-c.org/ns/1.0";

declare function pmf:code($config as map(*), $node as element(), 
    $class as xs:string, $content as node()*, $lang as item()?) {
    &lt;pre class="sourcecode" data-language="{if ($lang) then $lang else 'xquery'}"&gt;
    {$config?apply($config, $content/node())}
    &lt;/pre&gt;
};</code>
                    <p>It defines one function, <code>pmf:code</code>, which can be called from the ODD as follows:</p>
                    <code lang="xml">&lt;model behaviour="code"&gt;
    &lt;param name="lang"&gt;@lang&lt;/param&gt;
&lt;/model&gt;</code>
                </div>
                <div>
                    <head>App generator</head>
                    <p>here goes whatever needs sayin' about the wonders of app generator</p>
                </div>
                <div>
                    <head>TEI PM as a library</head>
                    <p>To use the library, import the utility module:</p>
                    <code lang="xquery">import module namespace pmu="http://www.tei-c.org/tei-simple/xquery/util" at "../content/util.xql";</code>
                    <p>The main function of the utility module is:</p>
                    <code lang="xquery">pmu:process($oddPath as xs:string, $xml as node()*, $output-root as xs:string, $mode as xs:string, $relPath as xs:string, $ext-modules as map(*)*)</code>
                    <p>The parameters are as follows:</p>
                    <table>
                        <row>
                            <cell>
                                <code>$oddPath</code>
                            </cell>
                            <cell>Absolute path to the ODD file containing the processing model instructions 
                                to use</cell>
                        </row>
                        <row>
                            <cell>
                                <code>$xml</code>
                            </cell>
                            <cell>The XML nodes to render. Any sequence of nodes is allowed here.</cell>
                        </row>
                        <row>
                            <cell>
                                <code>$output-root</code>
                            </cell>
                            <cell>Absolute path to a database collection which is used for 
                                caching the generated XQuery modules</cell>
                        </row>
                        <row>
                            <cell>
                                <code>$mode</code>
                            </cell>
                            <cell>The output mode: either "web" or "fo" (for PDF output)</cell>
                        </row>
                        <row>
                            <cell>
                                <code>$relPath</code>
                            </cell>
                            <cell>A relative URL pointing to the output collection given in 
                            <code>$output-root</code>. This will be used by the web browser to locate the generated
                            CSS stylesheets, so it should be relative to the page URL viewed in the 
                            browser.</cell>
                        </row>
                        <row>
                            <cell>
                                <code>$config</code>
                            </cell>
                            <cell>An XML fragment defining any additional XQuery modules to be loaded
                            for the different odds and output modes. Use this to extend the default set
                            of behaviour functions with your own. For an example, check the supplied
                            configuration in <code>odd/configuration.xml</code>.</cell>
                        </row>
                    </table>
                    <p>A simple main query to transform a TEI document into HTML may use the function
                        as follows:</p>
                    <code lang="xquery">xquery version "3.0";
                        
declare namespace output="http://www.w3.org/2010/xslt-xquery-serialization";

import module namespace config="http://www.tei-c.org/tei-simple/config" at "config.xqm";
import module namespace pmu="http://www.tei-c.org/tei-simple/xquery/util" at "../content/util.xql";
import module namespace odd="http://www.tei-c.org/tei-simple/odd2odd" at "../content/odd2odd.xql";

declare option output:method "html";
declare option output:html-version "5.0";
declare option output:media-type "text/html";

let $doc := request:get-parameter("doc", ())
let $odd := request:get-parameter("odd", "teisimple.odd")
return
    if ($doc) then
        let $odd := odd:get-compiled($config:odd-root, $odd, $config:compiled-odd-root)
        let $xml := doc($config:app-root || "/" || $doc)
        return
            pmu:process($odd, $xml, $config:output-root, "web", "../generated", $config:module-config)
    else
        &lt;p&gt;No document specified&lt;/p&gt;</code>
                    <p>After calling this the first time, the specified output collection:
                    <code>/db/test/generated</code> should contain 3 new files:</p>
                    <list>
                        <item>teisimple-web.xql</item>
                        <item>teisimple-web-main.xql</item>
                        <item>teisimple.css</item>
                    </list>
                    <p>The CSS file is automatically included into the HTML header if the transformation
                    is run on a complete TEI document. If you would like to embed the generated HTML
                    into an existing page, you should import the CSS in the header manually.</p>
                </div>
                <div>
                    <head>FO Output</head>
                    <p>When generating XSL:FO output, the implementation tries to translate the CSS rules
                        specified for renditions into the corresponding XSL:FO formatting properties.
                        Not all CSS properties are recognized. Unknown properties defined in a rendition 
                        will be ignored.</p>
                    <p>The default rendering for headings, paragraphs and the like is defined by a separate
                        CSS file. The implementation merges those defaults with the custom renditions given
                        in the ODD.</p>
                    <p>The library searches for default CSS styles in a file named 
                        <code>&lt;odd-name&gt;.fo.css</code> inside the specified output collection
                    (in which the generated XQuery files are stored). The style definitions are copied literally into attributes on
                    the output XSL:FO elements, so any property which is a valid attribute for the corresponding element 
                    may be used.</p>
                    <p>
                        The default styles file can also used to set general properties like the page
                        size or the appearance of the page header:</p>
                    <code lang="css">@page:left {
    margin-bottom: 10mm;
    margin-top: 10mm;
    margin-left: 36mm;
    margin-right: 18mm;
}
@page:right {
    margin-bottom: 10mm;
    margin-top: 10mm;
    margin-left: 18mm;
    margin-right: 36mm;
}
@page:head {
    margin-bottom: 0.7mm; 
    text-align-last: justify; 
    font-size: 10pt;
}</code>
                </div>
            </div>
        </body>
    </text>
</TEI>